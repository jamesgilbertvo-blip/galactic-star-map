<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Star Map</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #111827; color: #d1d5db; font-family: 'Inter', sans-serif; }
        canvas { touch-action: none; cursor: grab; background-color: #1f2937; border-radius: 0.5rem; }
        canvas:active { cursor: grabbing; }
        .hidden { display: none; }
        input:focus {
            box-shadow: 0 0 0 2px #4f46e5;
        }
        .logo-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1rem;
        }
        .logo-container img {
            width: 100px;
            height: 100px;
            z-index: 1;
            animation: float 6s ease-in-out infinite;
        }
        .logo-container::before {
            content: '';
            position: absolute;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(56, 189, 248, 0.15), transparent 70%);
            border-radius: 50%;
            z-index: 0;
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
    </style>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
</head>
<body class="h-screen antialiased overflow-hidden">

    <div id="login-view" class="flex items-center justify-center h-full">
        <div class="w-full max-w-md p-8 space-y-8 bg-gray-900 rounded-lg shadow-lg">
            <div class="logo-container"><img src="/logo.png" alt="Galactic Star Map Logo"></div>
            <div><h2 class="text-3xl font-extrabold text-center text-white">Sign In</h2><p class="mt-2 text-sm text-center text-gray-400">to view your star map</p></div>
            <form id="login-form" class="mt-8 space-y-6">
                <div class="rounded-md shadow-sm -space-y-px"><input id="username" name="username" type="text" required class="relative block w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-t-md placeholder-gray-400 focus:outline-none focus:ring-indigo-500" placeholder="Username"><input id="password" name="password" type="password" required class="relative block w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-b-md placeholder-gray-400 focus:outline-none focus:ring-indigo-500" placeholder="Password"></div>
                <div><button type="submit" class="w-full px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700">Sign in</button></div>
                <p id="login-error" class="text-sm text-center text-red-400 h-4" aria-live="assertive"></p>
            </form>
            <div class="text-sm text-center text-gray-400">
                <p>Don't have an account? <button id="show-register-view-button" class="font-medium text-indigo-400 hover:text-indigo-300">Register</button></p>
                <p class="mt-2">Need help? <a href="/guide.html" class="font-medium text-indigo-400 hover:text-indigo-300">Read the User Guide</a></p>
            </div>
        </div>
    </div>
    <div id="register-view" class="hidden flex items-center justify-center h-full">
        <div class="w-full max-w-md p-8 space-y-8 bg-gray-900 rounded-lg shadow-lg">
            <div class="logo-container"><img src="/logo.png" alt="Galactic Star Map Logo"></div>
            <div><h2 class="text-3xl font-extrabold text-center text-white">Create Account</h2><p class="mt-2 text-sm text-center text-gray-400">to start building your map</p></div>
            <form id="register-form" class="mt-8 space-y-6">
                <div class="rounded-md shadow-sm -space-y-px">
                    <input id="register-username" name="username" type="text" required class="w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-t-md placeholder-gray-400 focus:outline-none focus:ring-indigo-500" placeholder="Username">
                    <input id="register-password" name="password" type="password" required class="w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 placeholder-gray-400 focus:outline-none focus:ring-indigo-500" placeholder="Password">
                    <input id="register-api-key" name="api_key" type="text" required class="w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-b-md placeholder-gray-400 focus:outline-none focus:ring-indigo-500" placeholder="Game API Key">
                </div>
                <p class="text-xs text-gray-400 text-center px-2">Please be aware that using an API key on any third-party service carries inherent security risks, even with encryption.</p>
                <div><button type="submit" class="w-full px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700">Create Account</button></div>
                 <p id="register-error" class="text-sm text-center text-red-400 h-4" aria-live="assertive"></p>
            </form>
            <div class="text-sm text-center text-gray-400">
                <p>Already have an account? <button id="show-login-view-button" class="font-medium text-indigo-400 hover:text-indigo-300">Sign In</button></p>
                <p class="mt-2">Need help? <a href="/guide.html" class="font-medium text-indigo-400 hover:text-indigo-300">Read the User Guide</a></p>
            </div>
        </div>
    </div>
    <div id="profile-view" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="w-full max-w-md p-8 space-y-6 bg-gray-900 rounded-lg shadow-lg">
            <div class="flex justify-between items-center"><h2 class="text-2xl font-bold text-white">Manage Profile</h2><button id="close-profile-button" class="text-gray-400 hover:text-white">&times;</button></div>
            <form id="profile-form" class="space-y-4">
                <div><label for="api-key-input" class="block text-sm font-medium text-gray-300">API Key</label><input id="api-key-input" type="text" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-indigo-500" placeholder="Enter your game API key"></div>
                <div><label for="new-password-input" class="block text-sm font-medium text-gray-300">New Password (optional)</label><input id="new-password-input" type="password" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-indigo-500" placeholder="Leave blank to keep current password"></div>
                <div><button type="submit" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md">Save Changes</button></div>
            </form>
            <div class="border-t border-gray-700 pt-4">
                <button id="bulk-sync-button" type="button" class="hidden w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md">One-Time Faction System Import</button>
                <p id="bulk-sync-text" class="hidden text-xs text-gray-400 text-center mt-2">Populate your map with all known Faction & POI systems. This is only shown once for new factions.</p>
            </div>
            <p id="profile-status" class="text-sm text-center h-4" aria-live="assertive"></p>
        </div>
    </div>

    <div id="map-view" class="hidden flex h-screen overflow-hidden">
        <aside id="side-panel" class="absolute top-0 left-0 z-20 h-full w-full max-w-sm transform -translate-x-full transition-transform duration-300 ease-in-out md:relative md:max-w-xs md:translate-x-0 lg:max-w-sm bg-gray-900 p-6 flex-shrink-0 overflow-y-auto">
            <div class="space-y-6">
                <header class="flex items-center justify-between">
                    <div><h1 class="text-2xl font-bold text-white">Galactic Star Map</h1><p id="welcome-message" class="text-sm text-gray-400"></p></div>
                    <div id="user-controls" class="flex space-x-2">
                        <a href="/guide.html" class="px-3 py-1 text-sm font-medium text-white bg-gray-600 rounded-md hover:bg-gray-700">Guide</a>
                        <button id="profile-button" class="px-3 py-1 text-sm font-medium text-white bg-gray-600 rounded-md hover:bg-gray-700">Profile</button>
                        <button id="logout-button" class="px-3 py-1 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700">Logout</button>
                    </div>
                </header>
                <div id="sync-container" class="border-t border-b border-gray-700 py-4 space-y-3">
                    <button id="sync-button" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md">Sync Map Data</button>
                    <p id="sync-status" class="text-sm text-center text-gray-400 mt-2 h-4" aria-live="assertive"></p>
                </div>
                <form id="route-form" class="space-y-4">
                    <input type="text" id="start-system-input" list="system-list" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-indigo-500" placeholder="Start System or #Position...">
                    <input type="text" id="end-system-input" list="system-list" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-indigo-500" placeholder="End System or #Position...">
                    <datalist id="system-list"></datalist>
                    <div class="flex items-center pt-2">
                        <input id="filter-avoid-slow" type="checkbox" class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-indigo-600 focus:ring-indigo-500">
                        <label for="filter-avoid-slow" class="ml-2 block text-sm text-gray-300">Avoid Slow Sublight Regions</label>
                    </div>
                    <button type="submit" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md">Find Shortest Path</button>
                </form>
                <div id="route-details" aria-live="polite" class="space-y-2"></div>
                
                <div class="border-t border-gray-700 pt-4 space-y-4">
                    <h3 class="text-lg font-semibold text-white">Search & Filters</h3>
                    <form id="search-form" class="space-y-2">
                        <input type="text" id="search-input" list="system-list" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-indigo-500" placeholder="Find & Center on System...">
                        <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md text-sm">Search</button>
                    </form>
                    <div class="space-y-2">
                         <div class="flex items-center">
                             <input id="filter-catapults" type="checkbox" checked class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-indigo-600 focus:ring-indigo-500">
                             <label for="filter-catapults" class="ml-2 block text-sm text-gray-300">Show Catapult Ranges</label>
                         </div>
                        <div class="flex items-center">
                             <input id="filter-wormholes" type="checkbox" checked class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-indigo-600 focus:ring-indigo-500">
                             <label for="filter-wormholes" class="ml-2 block text-sm text-gray-300">Show Wormholes</label>
                        </div>
                        </div>
                </div>

                <div class="border-t border-gray-700 pt-4 space-y-2" aria-hidden="true">
                    <h3 class="text-lg font-semibold text-white">Display Options</h3>
                    <div class="flex items-center">
                        <input id="toggle-unclaimed-names" type="checkbox" class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-indigo-600 focus:ring-indigo-500">
                        <label for="toggle-unclaimed-names" class="ml-2 block text-sm text-gray-300">Show Unclaimed Names</label>
                    </div>
                    <p class="text-xs text-gray-500">Click a system to highlight its range. Long-press/Shift+Click to toggle.</p>
                    <button id="reset-view-button" class="mt-2 w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md text-sm">Reset View</button>
                </div>
            </div>
        </aside>

        <main class="relative flex-grow flex items-center justify-center">
            <button id="menu-button" class="md:hidden absolute top-4 left-4 z-30 p-2 bg-gray-800 text-white rounded-md flex items-center space-x-2" title="Toggle Menu" aria-label="Toggle map controls panel" aria-controls="side-panel" aria-expanded="true">
                <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                <span class="text-sm">Toggle Controls</span>
            </button>
            <button id="center-me-button" class="absolute bottom-4 right-4 z-10 p-2 bg-gray-800 text-white rounded-full shadow-lg" title="Center on last known location">
                <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path d="M10 8a2 2 0 100-4 2 2 0 000 4z" /><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm0 2a10 10 0 100-20 10 10 0 000 20z" clip-rule="evenodd" /></svg>
            </button>
            <canvas id="map-canvas" class="w-full h-full"></canvas>
        </main>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        let systems = {}; let wormholes = []; let calculatedPathNodes = []; let viewTransform = { scale: 1, translateX: 0, translateY: 0 }; 
        let isMouseDown = false; let isDragging = false; let dragStartPos = { x: 0, y: 0 }; let lastDragPosition = {x:0, y:0};
        const SPIRAL_TIGHTNESS = 0.1; const SPIRAL_SCALE = 50;
        let toggledCatapultIds = new Set();
        let activeRouteInput = null;
        let hoveredSystem = null;
        let showUnclaimedNames = false;
        let highlightedCatapultSystemId = null;
        let longPressTimer; let initialTouchDistance = null;
        let newlySyncedSystemIds = new Set();
        let highlightedSearchSystemId = null;
        let filterShowCatapults = true;
        let filterShowWormholes = true;
        let showBulkSyncButton = false;
        let lastKnownSystemId = null; 
        
        // --- State for "Center on Me" animation ---
        let pingAnimation = null; 
        let isAnimatingPing = false; 
        let pingAnimationFrameId = null; 
        // --- END ---

        const dom = { 
            loginView: document.getElementById('login-view'), mapView: document.getElementById('map-view'), registerView: document.getElementById('register-view'), 
            loginForm: document.getElementById('login-form'), registerForm: document.getElementById('register-form'), profileView: document.getElementById('profile-view'), 
            canvas: document.getElementById('map-canvas'), ctx: document.getElementById('map-canvas').getContext('2d'), loginError: document.getElementById('login-error'), 
            logoutButton: document.getElementById('logout-button'), welcomeMessage: document.getElementById('welcome-message'), 
            syncContainer: document.getElementById('sync-container'), syncButton: document.getElementById('sync-button'), syncStatus: document.getElementById('sync-status'), 
            routeForm: document.getElementById('route-form'), startSystemInput: document.getElementById('start-system-input'), endSystemInput: document.getElementById('end-system-input'), 
            systemDataList: document.getElementById('system-list'), routeDetailsContainer: document.getElementById('route-details'), 
            profileButton: document.getElementById('profile-button'), closeProfileButton: document.getElementById('close-profile-button'), profileForm: document.getElementById('profile-form'), 
            apiKeyInput: document.getElementById('api-key-input'), newPasswordInput: document.getElementById('new-password-input'), profileStatus: document.getElementById('profile-status'), 
            registerError: document.getElementById('register-error'), showRegisterViewButton: document.getElementById('show-register-view-button'), showLoginViewButton: document.getElementById('show-login-view-button'), 
            userControls: document.getElementById('user-controls'), 
            resetViewButton: document.getElementById('reset-view-button'), toggleUnclaimedNames: document.getElementById('toggle-unclaimed-names'),
            sidePanel: document.getElementById('side-panel'),
            menuButton: document.getElementById('menu-button'),
            searchForm: document.getElementById('search-form'),
            searchInput: document.getElementById('search-input'),
            filterCatapults: document.getElementById('filter-catapults'),
            filterWormholes: document.getElementById('filter-wormholes'),
            filterAvoidSlow: document.getElementById('filter-avoid-slow'), // NEW Checkbox reference
            bulkSyncButton: document.getElementById('bulk-sync-button'),
            bulkSyncText: document.getElementById('bulk-sync-text'),
            centerMeButton: document.getElementById('center-me-button')
        };

        const apiFetch = (url, options = {}) => { options.credentials = 'include'; return fetch(url, options); };
        const handleLogin = async (e) => { e.preventDefault(); const r=await apiFetch('/login',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({username:dom.loginForm.username.value,password:dom.loginForm.password.value})}); const d=await r.json(); if(r.ok)showMapView(d); else dom.loginError.textContent=d.message||'Login failed.'; };
        const handleRegister = async (e) => { e.preventDefault(); const p={username:dom.registerForm.username.value,password:dom.registerForm.password.value,api_key:dom.registerForm.api_key.value}; const r=await apiFetch('/register',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(p)}); const d=await r.json(); if(r.ok)showMapView(d, true); else dom.registerError.textContent=d.message||'Registration failed.'; };
        const handleLogout = async () => { await apiFetch('/logout', { method: 'POST' }); localStorage.removeItem('mapViewTransform'); showLoginView(); };
        const checkLoginStatus = async () => { const r=await apiFetch('/status'); const d=await r.json(); if(d.logged_in)showMapView(d); else showLoginView(); };
        
        const handleSync = async () => {
            const oldSystemIds = new Set(Object.keys(systems));
            dom.syncStatus.textContent = 'Syncing...'; 
            dom.syncButton.disabled = true; 
            try { 
                const r = await apiFetch('/api/sync', {method:'POST'}); 
                const d = await r.json(); 
                dom.syncStatus.textContent = d.message || d.error; // Show error message if sync fails 
                if (r.ok) {
                    const statusRes = await apiFetch('/status'); 
                    const statusData = await statusRes.json();
                    if (statusData.logged_in) {
                        lastKnownSystemId = statusData.last_known_system_id; 
                    }
                    await fetchMapData(false, oldSystemIds);
                } else {
                    console.error("Sync failed:", d.error || `Status ${r.status}`);
                }
            } catch (e) { 
                dom.syncStatus.textContent = 'Error: Could not connect to server.'; 
                console.error("Sync connection error:", e);
            } finally { 
                dom.syncButton.disabled = false; 
                setTimeout(() => { dom.syncStatus.textContent = ''; }, 7000); 
            } 
        };

        const handleBulkSync = async (e) => {
            e.preventDefault();
            dom.profileStatus.textContent = 'Importing... this may take a moment.';
            dom.bulkSyncButton.disabled = true;
            try {
                const r = await apiFetch('/api/bulk_sync_faction_systems', {method: 'POST'});
                const d = await r.json();
                if (!r.ok) throw new Error(d.error || 'Failed to import.');
                
                dom.profileStatus.textContent = d.message;
                showBulkSyncButton = false;
                dom.bulkSyncButton.classList.add('hidden');
                dom.bulkSyncText.classList.add('hidden');
                await fetchMapData(false);
                setTimeout(closeProfile, 2000);

            } catch (e) {
                dom.profileStatus.textContent = `Error: ${e.message}`;
                dom.bulkSyncButton.disabled = false;
            }
        };

        const openProfile = async () => { 
            dom.profileStatus.textContent = ''; 
            dom.newPasswordInput.value = ''; 
            try {
                const r = await apiFetch('/api/profile'); 
                if (!r.ok) throw new Error(`Failed to load profile: ${r.statusText}`);
                const d = await r.json(); 
                dom.apiKeyInput.value = d.api_key_set ? '(Key is set and encrypted)' : ''; 
                dom.apiKeyInput.placeholder = d.api_key_set ? 'Enter a new key to overwrite' : 'Enter your game API key'; 
                
                if (showBulkSyncButton) {
                    dom.bulkSyncButton.classList.remove('hidden');
                    dom.bulkSyncText.classList.remove('hidden');
                    dom.bulkSyncButton.disabled = false;
                } else {
                    dom.bulkSyncButton.classList.add('hidden');
                    dom.bulkSyncText.classList.add('hidden');
                }
                dom.profileView.classList.remove('hidden'); 
            } catch (error) {
                 dom.profileStatus.textContent = `Error: ${error.message}`;
                 console.error("Profile load error:", error);
            }
        };
        const closeProfile = () => dom.profileView.classList.add('hidden');
        const handleProfileUpdate = async (e) => { e.preventDefault(); dom.profileStatus.textContent = 'Saving...'; const p={}; if (dom.apiKeyInput.value && dom.apiKeyInput.value !== '(Key is set and encrypted)') p.api_key = dom.apiKeyInput.value; if (dom.newPasswordInput.value) p.password = dom.newPasswordInput.value; try { const r=await apiFetch('/api/profile',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(p)}); if (!r.ok) throw new Error(`Save failed: ${r.statusText}`); const d=await r.json(); dom.profileStatus.textContent = d.message; setTimeout(closeProfile, 2000); } catch(error) { dom.profileStatus.textContent = `Error: ${error.message}`; console.error("Profile update error:", error); } };
        
        async function fetchMapData(shouldFit = true, oldSystemIds = null) { 
            try {
                const r = await apiFetch('/api/systems'); 
                if (!r.ok) { if (r.status === 401) handleLogout(); else throw new Error(`Failed to load systems: ${r.statusText}`); return; } 
                const d = await r.json(); 
                systems = d.systems; 
                wormholes = d.wormholes; 
                populateDataList(); 
                if (shouldFit) { fitMapToView(); }
                
                if (oldSystemIds) {
                    newlySyncedSystemIds.clear();
                    Object.keys(systems).forEach(id => {
                        if (!oldSystemIds.has(id)) {
                            newlySyncedSystemIds.add(id);
                        }
                    });
                    if (newlySyncedSystemIds.size > 0) {
                        setTimeout(() => {
                            newlySyncedSystemIds.clear();
                            drawMap();
                        }, 2000);
                    }
                }
                drawMap();
            } catch (e) { console.error("Failed to fetch or draw map data:", e); /* Optionally show error to user */ } 
        }

        // --- MODIFIED: findPath includes avoid_slow_regions ---
        async function findPath(startId, endId) { 
            const avoidSlow = dom.filterAvoidSlow.checked; // Get checkbox value
            dom.routeDetailsContainer.innerHTML = '<p class="text-gray-400">Calculating route...</p>'; // Loading indicator
            try {
                const r = await apiFetch('/api/path', { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ 
                        start_id: startId, 
                        end_id: endId,
                        avoid_slow_regions: avoidSlow // Send flag to backend
                    }), 
                }); 
                const d = await r.json();
                if (!r.ok) { throw new Error(d.error || `Calculation failed: ${r.statusText}`); }
                displayPathResults(d); 
            } catch (error) {
                 console.error("Pathfinding error:", error);
                 dom.routeDetailsContainer.innerHTML = `<p class="text-red-400">Error calculating route: ${error.message}</p>`;
            }
        }
        // --- END MODIFIED ---

        function showLoginView() { dom.mapView.classList.add('hidden'); dom.registerView.classList.add('hidden'); dom.loginView.classList.remove('hidden'); }
        function showRegisterView() { dom.mapView.classList.add('hidden'); dom.loginView.classList.add('hidden'); dom.registerView.classList.remove('hidden'); }
        
        function showMapView(data, isNewRegistration = false) {
            dom.loginView.classList.add('hidden'); dom.registerView.classList.add('hidden'); dom.mapView.classList.remove('hidden');
            dom.welcomeMessage.textContent = `Welcome, ${data.username}`;
            showBulkSyncButton = data.show_bulk_sync || false;
            lastKnownSystemId = data.last_known_system_id || null; 

            let adminBtn = document.getElementById('admin-button');
            if (data.is_admin && !adminBtn) { adminBtn = document.createElement('a'); adminBtn.id = 'admin-button'; adminBtn.href = '/admin'; adminBtn.textContent = 'Admin'; adminBtn.className = 'px-3 py-1 text-sm font-medium text-white bg-purple-600 rounded-md hover:bg-purple-700'; dom.userControls.prepend(adminBtn); } 
            else if (!data.is_admin && adminBtn) { adminBtn.remove(); }
            if (data.is_developer) { dom.syncContainer.classList.add('hidden'); } else { dom.syncContainer.classList.remove('hidden'); }
            
            resizeCanvas(); 

            if (!isNewRegistration) {
                const savedView = localStorage.getItem('mapViewTransform');
                if (savedView) { 
                    try { viewTransform = JSON.parse(savedView); } catch { /* Ignore parse error, use default */ }
                }
                fetchMapData(savedView ? false : true); // Fit only if no saved view
            } else {
                fetchMapData(true); // Always fit after registration
            }
        }
        function populateDataList() {
            dom.systemDataList.innerHTML = '';
            const options = new Set();
            Object.values(systems).forEach(s => {
                if (s.name) options.add(s.name);
                if (s.position) options.add(`#${s.position}`); 
            });
            Array.from(options).sort().forEach(val => { const o = document.createElement('option'); o.value = val; dom.systemDataList.appendChild(o); });
        }
        
        function displayPathResults(result) {
            dom.routeDetailsContainer.innerHTML = ''; // Clear loading/previous results
            calculatedPathNodes = result.path || [];
            const allNodes = {};
            calculatedPathNodes.forEach(p => allNodes[p.id] = p);
            
            // Get original input values *before* clearing them
            const startInputVal = dom.startSystemInput.value || (allNodes[result.detailed_path?.[0]?.from_id]?.name || 'Start');
            const endInputVal = dom.endSystemInput.value || (allNodes[result.detailed_path?.[result.detailed_path.length - 1]?.to_id]?.name || 'End');

            // Clear inputs *after* getting values
            dom.startSystemInput.value = '';
            dom.endSystemInput.value = '';
            
            if (result.detailed_path && result.detailed_path.length > 0 && result.distance != null) {
                let html = `<div class="flex justify-between items-center"><h2 class="text-lg font-semibold text-white">Route: ${startInputVal} to ${endInputVal}</h2><button id="clear-route-button" class="text-sm text-gray-400 hover:text-white focus:outline-none">&times; Clear</button></div><p class="text-sm text-gray-400">Total Distance: ${result.distance.toFixed(2)}</p><ol class="mt-2 space-y-2 text-sm max-h-60 overflow-y-auto pr-2">`; // Added max-height and scroll
                
                const getDisplayName = (node) => {
                    if (!node) return 'Unknown';
                    // Use #Position format if it's a virtual node or default name
                    if (node.id.toString().startsWith('virtual') || (node.name.startsWith("System ") && node.position)) {
                        return `#${node.position}`;
                    }
                    return node.name;
                };

                const startNode = allNodes[result.detailed_path[0].from_id];
                html += `<li class="text-gray-300">1. Start at: <span class="font-semibold text-white">${getDisplayName(startNode)}</span></li>`;
                
                result.detailed_path.forEach((leg, index) => { 
                    const travelMethod = leg.method.charAt(0).toUpperCase() + leg.method.slice(1); 
                    let color = 'text-amber-400'; // Default sublight
                    if (leg.method === 'wormhole') color = 'text-red-400'; 
                    if (leg.method === 'catapult') color = 'text-lime-400'; 
                    const toNode = allNodes[leg.to_id];
                    html += `<li class="text-gray-300">${index + 2}. <span class="font-semibold ${color}">${travelMethod}</span> to <span class="font-semibold text-white">${getDisplayName(toNode)}</span></li>`; 
                });
                html += `</ol>`; 
                dom.routeDetailsContainer.innerHTML = html;
            } else { 
                dom.routeDetailsContainer.innerHTML = `<h2 class="text-lg font-semibold text-white">No Route Found</h2><p class="text-yellow-400">A path could not be found between ${startInputVal} and ${endInputVal}. Check inputs or adjust filters.</p>`; 
            }
            drawMap(); // Redraw map to show the path lines
        }

        function toggleSidePanel() {
            const isExpanded = dom.menuButton.getAttribute('aria-expanded') === 'true';
            dom.sidePanel.classList.toggle('-translate-x-full');
            dom.menuButton.setAttribute('aria-expanded', !isExpanded);
        }
        
        // --- Animation loop for the ping ---
        function animatePing() {
            isAnimatingPing = true;
            
            if (!pingAnimation) {
                 isAnimatingPing = false;
                 pingAnimationFrameId = null;
                 drawMap(); 
                 return;
            }

            const elapsed = Date.now() - pingAnimation.startTime;
            
            if (elapsed > pingAnimation.duration) {
                pingAnimation = null;
                isAnimatingPing = false;
                pingAnimationFrameId = null;
                drawMap(); 
                return;
            }
            
            drawMap(); 
            pingAnimationFrameId = requestAnimationFrame(animatePing); 
        }

        // --- "Center on Me" function ---
        function centerOnMyLocation() {
            if (!lastKnownSystemId) {
                alert("No location known. Please sync your data first.");
                return;
            }
            const targetSystem = systems[lastKnownSystemId];
            if (!targetSystem) {
                alert("Your last known location is not in the discovered map. Please sync again.");
                return;
            }
            
            viewTransform.scale = 1.0; 
            viewTransform.translateX = (dom.canvas.width / 2) - (targetSystem.x * viewTransform.scale);
            viewTransform.translateY = (dom.canvas.height / 2) - (targetSystem.y * viewTransform.scale);
            
            drawMap(); 
            localStorage.setItem('mapViewTransform', JSON.stringify(viewTransform));
            highlightedSearchSystemId = null; // Clear search highlight
            
            // Always reset and restart animation
            if (isAnimatingPing && pingAnimationFrameId) {
                cancelAnimationFrame(pingAnimationFrameId);
            }
            pingAnimation = null;
            isAnimatingPing = false;
            pingAnimationFrameId = null;

            pingAnimation = { systemId: lastKnownSystemId, startTime: Date.now(), duration: 1200 };
            animatePing(); 
        }

        function clearRouteDisplay() { calculatedPathNodes = []; dom.routeDetailsContainer.innerHTML = ''; /* dom.startSystemInput.value = ''; dom.endSystemInput.value = ''; */ drawMap(); } // Don't clear inputs here
        function resizeCanvas() { if(dom.canvas.parentElement.clientWidth > 0){ dom.canvas.width = dom.canvas.clientWidth; dom.canvas.height = dom.canvas.clientHeight; if(dom.canvas.width > 0) drawMap(); } }
        function fitMapToView() { if (Object.keys(systems).length === 0) return; let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity; Object.values(systems).forEach(s => { if (typeof s.x === 'number' && typeof s.y === 'number'){ minX=Math.min(minX,s.x); maxX=Math.max(maxX,s.x); minY=Math.min(minY,s.y); maxY=Math.max(maxY,s.y); }}); if (!isFinite(minX)) return; const mapW=maxX-minX || 1, mapH=maxY-minY || 1; const mapCX=minX+mapW/2, mapCY=minY+mapH/2; const scale=Math.min(dom.canvas.width/(mapW*1.2), dom.canvas.height/(mapH*1.2))||1; viewTransform = { scale, translateX: (dom.canvas.width/2)-(mapCX*scale), translateY: (dom.canvas.height/2)-(mapCY*scale) }; localStorage.setItem('mapViewTransform', JSON.stringify(viewTransform));}
        const getSpiralPoint = (pos) => { const a=SPIRAL_TIGHTNESS, r=parseFloat(pos)*SPIRAL_SCALE/1000; return { x: r*Math.cos(parseFloat(pos)*a), y: r*Math.sin(parseFloat(pos)*a) }; }; // Ensure pos is float
        
        function drawMap() {
            if(!dom.canvas.width || !dom.ctx) return; const ctx = dom.ctx;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0,0,dom.canvas.width,dom.canvas.height);
            ctx.save();
            ctx.translate(viewTransform.translateX, viewTransform.translateY);
            ctx.scale(viewTransform.scale, viewTransform.scale);
            
            // Draw spiral guide
            const systemPositions = Object.values(systems).map(s => parseFloat(s.position)).filter(p => !isNaN(p));
            if(systemPositions.length > 0){ let maxPos=Math.max(...systemPositions); if(maxPos>0){ ctx.strokeStyle='rgba(75,85,99,0.2)';ctx.lineWidth=1/viewTransform.scale;ctx.beginPath();const s=1;ctx.moveTo(0,0);for(let p=s;p<=maxPos*1.1;p+=s)ctx.lineTo(getSpiralPoint(p).x,getSpiralPoint(p).y);ctx.stroke();}}
            
            // Draw catapult ranges
            if (filterShowCatapults) {
                Object.values(systems).forEach(sys => { 
                    const sysPos = parseFloat(sys.position);
                    const sysRadius = parseFloat(sys.catapult_radius);
                    if (isNaN(sysPos) || isNaN(sysRadius) || sysRadius <= 0) return;
                    
                    const isToggled = toggledCatapultIds.has(String(sys.id));
                    if (!isToggled) { 
                        let rangeColor = 'rgba(132, 204, 22, 0.3)';
                        if (highlightedCatapultSystemId !== null) { rangeColor = (sys.id === highlightedCatapultSystemId) ? 'rgba(163, 230, 57, 0.9)' : 'rgba(132, 204, 22, 0.05)'; }
                        ctx.strokeStyle = rangeColor; ctx.lineWidth = 2 / viewTransform.scale;
                        const startPos = sysPos - sysRadius; const endPos = sysPos + sysRadius;
                        const step = 1; 
                        ctx.beginPath(); ctx.moveTo(getSpiralPoint(startPos).x, getSpiralPoint(startPos).y);
                        for (let pos = startPos + step; pos < endPos; pos += step) { ctx.lineTo(getSpiralPoint(pos).x, getSpiralPoint(pos).y); }
                        ctx.lineTo(getSpiralPoint(endPos).x, getSpiralPoint(endPos).y); ctx.stroke();
                    }
                });
            }

            // Draw wormholes
            if (filterShowWormholes) {
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.4)'; ctx.lineWidth = 1 / viewTransform.scale; ctx.setLineDash([5 / viewTransform.scale, 5 / viewTransform.scale]);
                wormholes.forEach(wh => { const sA=systems[wh[0]], sB=systems[wh[1]]; if (sA && sB && typeof sA.x === 'number' && typeof sB.x === 'number') { ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke(); } });
                ctx.setLineDash([]);
            }
            
            // Draw path lines
            const calculatedPathIds = new Set(calculatedPathNodes.map(p => p.id));
            if (calculatedPathNodes.length > 1) {
                for (let i = 0; i < calculatedPathNodes.length - 1; i++) {
                    const sA = calculatedPathNodes[i];
                    const sB = calculatedPathNodes[i + 1];
                    const posA = parseFloat(sA.position); const posB = parseFloat(sB.position);

                    if (isNaN(posA) || isNaN(posB)) continue; // Skip if positions invalid

                    const isKnownSystemA = !sA.id.toString().startsWith('virtual');
                    const isKnownSystemB = !sB.id.toString().startsWith('virtual');
                    const isWormhole = isKnownSystemA && isKnownSystemB && new Set(wormholes.map(wh => `${Math.min(wh[0],wh[1])}-${Math.max(wh[0],wh[1])}`)).has(`${Math.min(sA.id,sB.id)}-${Math.max(sA.id,sB.id)}`);
                    const sysAData = systems[sA.id];
                    const isCatapult = isKnownSystemA && isKnownSystemB && sysAData?.catapult_radius > 0 && Math.abs(posA - posB) <= sysAData.catapult_radius;
                    
                    if (isWormhole) { ctx.strokeStyle='#ef4444'; ctx.lineWidth=3/viewTransform.scale; ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke(); } 
                    else if (isCatapult) { ctx.strokeStyle='#a3e635'; ctx.lineWidth=3/viewTransform.scale; ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke(); } 
                    else { // Sublight
                        ctx.strokeStyle='#f59e0b'; ctx.lineWidth=3/viewTransform.scale;
                        const s=1; ctx.beginPath(); ctx.moveTo(getSpiralPoint(posA).x,getSpiralPoint(posA).y); 
                        const dist = Math.abs(posB-posA);
                        const sign = Math.sign(posB-posA);
                        for (let j=1;j<=Math.floor(dist/s);j++){
                            const p = posA+(j*s*sign);
                            ctx.lineTo(getSpiralPoint(p).x, getSpiralPoint(p).y);
                        } 
                        ctx.lineTo(getSpiralPoint(posB).x,getSpiralPoint(posB).y);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw systems
            Object.values(systems).forEach(sys => {
                if (typeof sys.x !== 'number' || typeof sys.y !== 'number') { return; }
                const isOnPath = calculatedPathIds.has(String(sys.id));
                const isHovered = hoveredSystem && hoveredSystem.id === sys.id;
                const isNewlySynced = newlySyncedSystemIds.has(String(sys.id));
                const isSearched = highlightedSearchSystemId === sys.id;
                
                ctx.fillStyle = isOnPath || isSearched ? '#f59e0b' : '#38bdf8';
                ctx.beginPath();
                ctx.arc(sys.x, sys.y, (isOnPath || isHovered || isSearched ? 6 : 4) / viewTransform.scale, 0, Math.PI * 2);
                ctx.fill();

                if (isNewlySynced) {
                    ctx.strokeStyle = 'rgba(250, 204, 21, 0.9)';
                    ctx.lineWidth = 3 / viewTransform.scale;
                    ctx.stroke();
                }
            });

            // Draw virtual path nodes
            calculatedPathNodes.forEach(node => {
                if (node.id.toString().startsWith('virtual')) {
                    const size = 8 / viewTransform.scale;
                    ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2 / viewTransform.scale;
                    ctx.beginPath();
                    ctx.moveTo(node.x - size, node.y - size); ctx.lineTo(node.x + size, node.y + size);
                    ctx.moveTo(node.x + size, node.y - size); ctx.lineTo(node.x - size, node.y + size);
                    ctx.stroke();
                }
            });

            // Draw labels
            Object.values(systems).forEach(sys => {
                if (typeof sys.x !== 'number' || typeof sys.y !== 'number') return;
                const isOnPath = calculatedPathIds.has(String(sys.id));
                const isHovered = hoveredSystem && hoveredSystem.id === sys.id;
                const isSearched = highlightedSearchSystemId === sys.id;
                
                let labelText = sys.name;
                const isDefaultName = labelText && labelText.startsWith("System ");
                if (isDefaultName && typeof sys.position === 'string' && sys.position !== '') { 
                    labelText = `#${sys.position}`; 
                } else if (!labelText) {
                    labelText = `ID: ${sys.id}`; // Fallback if name is missing
                }

                let shouldShowLabel = (isOnPath || isHovered || isSearched || viewTransform.scale > 0.8);
                if (isDefaultName && !showUnclaimedNames && !isOnPath && !isHovered && !isSearched) { 
                    shouldShowLabel = false; 
                }

                if (shouldShowLabel) {
                    ctx.fillStyle = (isOnPath || isHovered || isSearched) ? '#ffffff' : '#e5e7eb';
                    ctx.font = `${(isOnPath || isHovered || isSearched ? 12 : 10) / viewTransform.scale}px Inter`;
                    ctx.textAlign = 'center';
                    ctx.fillText(labelText, sys.x, sys.y - ((isOnPath || isHovered || isSearched ? 10 : 8) / viewTransform.scale));
                }
            });

            // Draw virtual node labels
            calculatedPathNodes.forEach(node => {
                if (node.id.toString().startsWith('virtual')) {
                    const size = 8 / viewTransform.scale;
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${12 / viewTransform.scale}px Inter`;
                    ctx.textAlign = 'center';
                    ctx.fillText(node.name, node.x, node.y - (size + 4 / viewTransform.scale));
                }
            });

            // Draw the ping animation
            if (pingAnimation && systems[pingAnimation.systemId]) {
                const sys = systems[pingAnimation.systemId];
                if (typeof sys.x === 'number' && typeof sys.y === 'number') { // Check if system coords are valid
                    const elapsed = Date.now() - pingAnimation.startTime;
                    const progress = elapsed / pingAnimation.duration; 
                    
                    const maxRadius = (Math.max(dom.canvas.width, dom.canvas.height) / 2) / viewTransform.scale;
                    const currentRadius = Math.max(0, maxRadius * (1 - progress)); // Ensure radius doesn't go negative
                    const currentAlpha = Math.max(0, 1 - (progress * 0.8)); 
                    
                    if (currentRadius > 0 && currentAlpha > 0) { 
                        ctx.strokeStyle = `rgba(245, 158, 11, ${currentAlpha})`; 
                        ctx.lineWidth = 4 / viewTransform.scale;
                        ctx.beginPath();
                        ctx.arc(sys.x, sys.y, currentRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    const delay = 150; 
                    if (elapsed > delay) {
                        const progress2 = (elapsed - delay) / (pingAnimation.duration - delay);
                        const currentRadius2 = Math.max(0, maxRadius * (1 - progress2));
                        const currentAlpha2 = Math.max(0, 1 - (progress2 * 0.8));
                        
                        if (currentRadius2 > 0 && currentAlpha2 > 0) { 
                            ctx.lineWidth = 2 / viewTransform.scale; 
                            ctx.strokeStyle = `rgba(245, 158, 11, ${currentAlpha2})`; 
                            ctx.beginPath();
                            ctx.arc(sys.x, sys.y, currentRadius2, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                }
            }

            ctx.restore();
        }
        function handleToggleUnclaimedNames(e) { showUnclaimedNames = e.target.checked; drawMap(); }
        function handleResetView() { fitMapToView(); drawMap(); }

        function getEventCoordinates(e) {
            const rect = dom.canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function onInteractionStart(e) {
            isMouseDown = true; isDragging = false;
            const coords = getEventCoordinates(e);
            dragStartPos = { x: coords.x, y: coords.y };
            lastDragPosition = { x: coords.x, y: coords.y };
            
            clearTimeout(longPressTimer);
            longPressTimer = setTimeout(() => {
                if (!isDragging && hoveredSystem && hoveredSystem.catapult_radius > 0) {
                    const systemId = String(hoveredSystem.id);
                    if (toggledCatapultIds.has(systemId)) { toggledCatapultIds.delete(systemId); } 
                    else { toggledCatapultIds.add(systemId); }
                    drawMap();
                }
            }, 500);
        }

        function onInteractionMove(e) {
            // Prevent default only if dragging or multi-touch, allow text selection etc. otherwise
             if (isDragging || (e.touches && e.touches.length > 1)) {
                 e.preventDefault();
             }

            const coords = getEventCoordinates(e);
            const worldX = (coords.x - viewTransform.translateX) / viewTransform.scale;
            const worldY = (coords.y - viewTransform.translateY) / viewTransform.scale;
            
            let currentlyHovering = null;
            // Find closest system within hover radius
            let minDistSq = Math.pow(10 / viewTransform.scale, 2);
            for (const system of Object.values(systems)) {
                if (typeof system.x !== 'number' || typeof system.y !== 'number') continue;
                const dx = worldX - system.x; const dy = worldY - system.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < minDistSq) {
                     minDistSq = distSq;
                     currentlyHovering = system; 
                }
            }
            if (hoveredSystem !== currentlyHovering) { hoveredSystem = currentlyHovering; drawMap(); }

            // Handle pinch zoom
            if (e.touches && e.touches.length === 2) {
                isDragging = false; // Stop panning during pinch
                clearTimeout(longPressTimer); // Cancel long press if pinching
                const t1 = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                const t2 = { x: e.touches[1].clientX, y: e.touches[1].clientY };
                const dist = Math.hypot(t1.x - t2.x, t1.y - t2.y);
                if (initialTouchDistance) {
                    const scaleFactor = dist / initialTouchDistance;
                    const rect = dom.canvas.getBoundingClientRect();
                    const midX = (t1.x + t2.x) / 2 - rect.left; // Use rect for accuracy
                    const midY = (t1.y + t2.y) / 2 - rect.top;
                    const worldMidX = (midX - viewTransform.translateX) / viewTransform.scale;
                    const worldMidY = (midY - viewTransform.translateY) / viewTransform.scale;
                    viewTransform.scale *= scaleFactor;
                    // Clamp scale
                    viewTransform.scale = Math.max(0.05, Math.min(viewTransform.scale, 10)); 
                    viewTransform.translateX = midX - worldMidX * viewTransform.scale;
                    viewTransform.translateY = midY - worldMidY * viewTransform.scale;
                    drawMap();
                }
                initialTouchDistance = dist;
                return;
            } else {
                 initialTouchDistance = null; // Reset if not 2 touches
            }
            
            // Handle panning (mouse or single touch)
            let cursorStyle = hoveredSystem ? 'pointer' : 'grab';
            if (isMouseDown && (!e.touches || e.touches.length === 1)) { // Only pan with mouse or 1 touch
                clearTimeout(longPressTimer);
                if (!isDragging && (Math.hypot(coords.x - dragStartPos.x, coords.y - dragStartPos.y) > 5)) { // Use hypotenuse for drag threshold
                    isDragging = true;
                }
                if (isDragging) {
                    cursorStyle = 'grabbing';
                    const dx = coords.x - lastDragPosition.x;
                    const dy = coords.y - lastDragPosition.y;
                    viewTransform.translateX += dx;
                    viewTransform.translateY += dy;
                    lastDragPosition = { x: coords.x, y: coords.y };
                    drawMap();
                }
            }
            dom.canvas.style.cursor = cursorStyle; // Update cursor style
        }
        
        function onInteractionEnd(e) {
            clearTimeout(longPressTimer);
            if (!isDragging) { // Only process clicks/taps if not dragging
                if (hoveredSystem) {
                    if (e.shiftKey) { // Shift+Click (Desktop)
                         if (hoveredSystem.catapult_radius > 0) {
                            const systemId = String(hoveredSystem.id);
                            if (toggledCatapultIds.has(systemId)) { toggledCatapultIds.delete(systemId); } 
                            else { toggledCatapultIds.add(systemId); }
                        }
                    } else if (activeRouteInput) { // Click/Tap to populate route input
                        const sysPosStr = systems[hoveredSystem.id]?.position; // Get updated position string
                        if (hoveredSystem.name.startsWith("System ") && sysPosStr) {
                            activeRouteInput.value = `#${sysPosStr}`;
                        } else {
                            activeRouteInput.value = hoveredSystem.name;
                        }

                        if (activeRouteInput === dom.startSystemInput) { dom.endSystemInput.focus(); } 
                        else { dom.routeForm.querySelector('button[type="submit"]').focus(); }
                        activeRouteInput = null; // Deactivate after populating
                    }
                    highlightedCatapultSystemId = hoveredSystem.id; // Highlight range on simple click/tap
                } else {
                    highlightedCatapultSystemId = null; // Clear range highlight if clicking empty space
                }
                drawMap();
            }
            // Reset interaction state
            isMouseDown = false;
            isDragging = false;
            initialTouchDistance = null;
            dom.canvas.style.cursor = hoveredSystem ? 'pointer' : 'grab'; // Reset cursor
            localStorage.setItem('mapViewTransform', JSON.stringify(viewTransform)); // Save view on interaction end
        }

        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);
            dom.loginForm.addEventListener('submit', handleLogin);
            dom.registerForm.addEventListener('submit', handleRegister);
            dom.logoutButton.addEventListener('click', handleLogout);
            dom.syncButton.addEventListener('click', handleSync);
            dom.profileButton.addEventListener('click', openProfile);
            dom.closeProfileButton.addEventListener('click', closeProfile);
            dom.profileForm.addEventListener('submit', handleProfileUpdate);
            dom.showRegisterViewButton.addEventListener('click', showRegisterView);
            dom.showLoginViewButton.addEventListener('click', showLoginView);
            dom.toggleUnclaimedNames.addEventListener('change', (e) => { showUnclaimedNames = e.target.checked; drawMap(); });
            dom.resetViewButton.addEventListener('click', handleResetView);
            dom.menuButton.addEventListener('click', toggleSidePanel);
            dom.centerMeButton.addEventListener('click', centerOnMyLocation); 
            
            dom.routeForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const startVal = dom.startSystemInput.value.trim();
                const endVal = dom.endSystemInput.value.trim();
                const parseInput = (val) => {
                    if (!val) return null; // Handle empty input
                    // Match # followed by digits and optional decimal part
                    if (val.match(/^#\d+(\.\d+)?$/)) { 
                        const pos = parseFloat(val.substring(1)); 
                        return !isNaN(pos) ? `pos:${pos}` : null; 
                    }
                    // Find system by name (case-insensitive) OR exact #position match from datalist
                    const system = Object.values(systems).find(s => 
                        (s.name && s.name.toLowerCase() === val.toLowerCase()) || 
                        (s.position && `#${s.position}` === val)
                    );
                    return system ? `sys:${system.id}` : null;
                };
                const startId = parseInput(startVal);
                const endId = parseInput(endVal);
                if (startId && endId) { findPath(startId, endId); } 
                else { 
                    dom.routeDetailsContainer.innerHTML = `<p class="text-red-400">Could not find one or both locations. Please use a known system name or format coordinates as #123.45</p>`; 
                    calculatedPathNodes = []; // Clear old path on error
                    drawMap();
                }
            });

            dom.searchForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const query = dom.searchInput.value.trim().toLowerCase();
                const foundSystem = Object.values(systems).find(s => 
                    (s.name && s.name.toLowerCase() === query) || 
                    (s.position && `#${s.position}` === query)
                 );
                if (foundSystem && typeof foundSystem.x === 'number') { // Check coordinates are valid
                    viewTransform.scale = 1.5; // Zoom in a bit more
                    viewTransform.translateX = (dom.canvas.width / 2) - (foundSystem.x * viewTransform.scale);
                    viewTransform.translateY = (dom.canvas.height / 2) - (foundSystem.y * viewTransform.scale);
                    
                    highlightedSearchSystemId = foundSystem.id;
                    drawMap();
                    localStorage.setItem('mapViewTransform', JSON.stringify(viewTransform)); // Save view after search

                    setTimeout(() => {
                        if (highlightedSearchSystemId === foundSystem.id) { // Only clear if it hasn't changed
                            highlightedSearchSystemId = null;
                            drawMap();
                        }
                    }, 2000);
                } else {
                    alert("System not found or has invalid coordinates in your discovered map.");
                }
            });

            dom.filterCatapults.addEventListener('change', (e) => { filterShowCatapults = e.target.checked; drawMap(); });
            dom.filterWormholes.addEventListener('change', (e) => { filterShowWormholes = e.target.checked; drawMap(); });
            dom.bulkSyncButton.addEventListener('click', handleBulkSync);

            // Activate input field for map clicks
            dom.startSystemInput.addEventListener('focus', () => { activeRouteInput = dom.startSystemInput; });
            dom.endSystemInput.addEventListener('focus', () => { activeRouteInput = dom.endSystemInput; });
            // Deactivate if clicking outside relevant areas
            document.addEventListener('click', (e) => { if (!dom.routeForm.contains(e.target) && !dom.canvas.contains(e.target)) { activeRouteInput = null; }});
            // Clear route display button
            dom.routeDetailsContainer.addEventListener('click', (e) => { if (e.target && e.target.id === 'clear-route-button') { clearRouteDisplay(); } });

            // Canvas interaction listeners
            dom.canvas.addEventListener('mousedown', onInteractionStart); 
            dom.canvas.addEventListener('mousemove', onInteractionMove);
            dom.canvas.addEventListener('mouseup', onInteractionEnd); 
            dom.canvas.addEventListener('mouseleave', onInteractionEnd); // Treat leaving canvas like mouse up
            dom.canvas.addEventListener('wheel', (e) => { 
                e.preventDefault(); 
                const scaleAmount = 1.1;
                const rect = dom.canvas.getBoundingClientRect();
                const mX=e.clientX - rect.left, mY=e.clientY - rect.top; 
                const wX=(mX-viewTransform.translateX)/viewTransform.scale, wY=(mY-viewTransform.translateY)/viewTransform.scale; 
                
                if(e.deltaY < 0) viewTransform.scale *= scaleAmount; // Zoom in
                else viewTransform.scale /= scaleAmount; // Zoom out
                
                // Clamp scale
                viewTransform.scale = Math.max(0.05, Math.min(viewTransform.scale, 10)); 

                viewTransform.translateX=mX-wX*viewTransform.scale; 
                viewTransform.translateY=mY-wY*viewTransform.scale; 
                drawMap(); 
                localStorage.setItem('mapViewTransform', JSON.stringify(viewTransform)); 
            }, { passive: false }); // Need passive: false to preventDefault()
            
            // Touch events
            dom.canvas.addEventListener('touchstart', onInteractionStart, { passive: false }); // Need passive: false for preventDefault in move
            dom.canvas.addEventListener('touchmove', onInteractionMove, { passive: false }); // Need passive: false for preventDefault
            dom.canvas.addEventListener('touchend', onInteractionEnd);
            dom.canvas.addEventListener('touchcancel', onInteractionEnd); // Treat cancel like end
        }
        
        setupEventListeners();
        checkLoginStatus();
    });
    </script>
</body>
</html>