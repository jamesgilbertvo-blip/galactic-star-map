<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Star Map</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #111827; color: #d1d5db; font-family: 'Inter', sans-serif; }
        canvas { touch-action: none; cursor: grab; background-color: #1f2937; border-radius: 0.5rem; }
        canvas:active { cursor: grabbing; }
        .hidden { display: none; }
        input:focus, select:focus, textarea:focus {
            box-shadow: 0 0 0 2px #4f46e5;
            outline: none;
        }
        .logo-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1rem;
        }
        .logo-container img {
            width: 100px;
            height: 100px;
            z-index: 1;
            animation: float 6s ease-in-out infinite;
        }
        .logo-container::before {
            content: '';
            position: absolute;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(56, 189, 248, 0.15), transparent 70%);
            border-radius: 50%;
            z-index: 0;
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        /* Context Menu Styling */
        #intel-context-menu {
            position: absolute;
            z-index: 50;
            min-width: 200px;
        }
    </style>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
</head>
<body class="h-screen antialiased overflow-hidden relative">

    <div id="intel-context-menu" class="hidden bg-gray-800 border border-gray-700 rounded-lg shadow-xl p-4 flex-col space-y-3">
        <h3 id="intel-menu-title" class="text-sm font-bold text-white border-b border-gray-700 pb-2">Add Intel Marker</h3>
        <div class="text-xs text-gray-400" id="intel-coords-display"></div>
        <select id="intel-type-input" class="bg-gray-700 border border-gray-600 rounded text-white text-sm p-2">
            <option value="Mining Rich">Mining Rich</option>
            <option value="Hazard">Hazard</option>
            <option value="Point of Interest">Point of Interest</option>
        </select>
        <textarea id="intel-note-input" placeholder="Optional notes..." class="bg-gray-700 border border-gray-600 rounded text-white text-sm p-2 h-16 resize-none"></textarea>
        <div class="flex justify-between pt-2">
             <button id="delete-intel-btn" class="hidden px-3 py-1 text-xs bg-red-600 hover:bg-red-700 text-white rounded">Delete</button>
            <div class="flex space-x-2 ml-auto">
                <button id="cancel-intel-btn" class="px-3 py-1 text-xs text-gray-300 hover:text-white">Cancel</button>
                <button id="save-intel-btn" class="px-3 py-1 text-xs bg-indigo-600 hover:bg-indigo-700 text-white rounded">Save</button>
            </div>
        </div>
    </div>

    <div id="login-view" class="flex items-center justify-center h-full">
        <div class="w-full max-w-md p-8 space-y-8 bg-gray-900 rounded-lg shadow-lg">
            <div class="logo-container"><img src="/logo.png" alt="Galactic Star Map Logo"></div>
            <div><h2 class="text-3xl font-extrabold text-center text-white">Sign In</h2><p class="mt-2 text-sm text-center text-gray-400">to view your star map</p></div>
            <form id="login-form" class="mt-8 space-y-6">
                <div class="rounded-md shadow-sm -space-y-px"><input id="username" name="username" type="text" required class="relative block w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-t-md placeholder-gray-400 focus:outline-none focus:ring-indigo-500" placeholder="Username"><input id="password" name="password" type="password" required class="relative block w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-b-md placeholder-gray-400 focus:outline-none focus:ring-indigo-500" placeholder="Password"></div>
                <div><button type="submit" class="w-full px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700">Sign in</button></div>
                <p id="login-error" class="text-sm text-center text-red-400 h-4" aria-live="assertive"></p>
            </form>
            <div class="text-sm text-center text-gray-400">
                <p>Don't have an account? <button id="show-register-view-button" class="font-medium text-indigo-400 hover:text-indigo-300">Register</button></p>
                <p class="mt-2">Need help? <a href="/guide.html" class="font-medium text-indigo-400 hover:text-indigo-300">Read the User Guide</a></p>
            </div>
        </div>
    </div>
    <div id="register-view" class="hidden flex items-center justify-center h-full">
        <div class="w-full max-w-md p-8 space-y-8 bg-gray-900 rounded-lg shadow-lg">
            <div class="logo-container"><img src="/logo.png" alt="Galactic Star Map Logo"></div>
            <div><h2 class="text-3xl font-extrabold text-center text-white">Create Account</h2><p class="mt-2 text-sm text-center text-gray-400">to start building your map</p></div>
            <form id="register-form" class="mt-8 space-y-6">
                <div class="rounded-md shadow-sm -space-y-px">
                    <input id="register-username" name="username" type="text" required class="w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-t-md placeholder-gray-400 focus:outline-none focus:ring-indigo-500" placeholder="Username">
                    <input id="register-password" name="password" type="password" required class="w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 placeholder-gray-400 focus:outline-none focus:ring-indigo-500" placeholder="Password">
                    <input id="register-api-key" name="api_key" type="text" required class="w-full px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-b-md placeholder-gray-400 focus:outline-none focus:ring-indigo-500" placeholder="Game API Key">
                </div>
                <p class="text-xs text-gray-400 text-center px-2">Please be aware that using an API key on any third-party service carries inherent security risks, even with encryption.</p>
                <div><button type="submit" class="w-full px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700">Create Account</button></div>
                 <p id="register-error" class="text-sm text-center text-red-400 h-4" aria-live="assertive"></p>
            </form>
            <div class="text-sm text-center text-gray-400">
                <p>Already have an account? <button id="show-login-view-button" class="font-medium text-indigo-400 hover:text-indigo-300">Sign In</button></p>
                <p class="mt-2">Need help? <a href="/guide.html" class="font-medium text-indigo-400 hover:text-indigo-300">Read the User Guide</a></p>
            </div>
        </div>
    </div>
    <div id="profile-view" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="w-full max-w-md p-8 space-y-6 bg-gray-900 rounded-lg shadow-lg">
            <div class="flex justify-between items-center"><h2 class="text-2xl font-bold text-white">Manage Profile</h2><button id="close-profile-button" class="text-gray-400 hover:text-white">&times;</button></div>
            <form id="profile-form" class="space-y-4">
                <div><label for="api-key-input" class="block text-sm font-medium text-gray-300">API Key</label><input id="api-key-input" type="text" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-indigo-500" placeholder="Enter your game API key"></div>
                <div><label for="new-password-input" class="block text-sm font-medium text-gray-300">New Password (optional)</label><input id="new-password-input" type="password" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-indigo-500" placeholder="Leave blank to keep current password"></div>
                <div><button type="submit" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md">Save Changes</button></div>
            </form>
            <div class="border-t border-gray-700 pt-4">
                <button id="bulk-sync-button" type="button" class="hidden w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md">One-Time Faction System Import</button>
                <p id="bulk-sync-text" class="hidden text-xs text-gray-400 text-center mt-2">Populate your map with all known Faction & POI systems. This is only shown once for new factions.</p>
            </div>
            <p id="profile-status" class="text-sm text-center h-4" aria-live="assertive"></p>
        </div>
    </div>

    <div id="map-view" class="hidden flex h-screen overflow-hidden">
        <aside id="side-panel" class="absolute top-0 left-0 z-20 h-full w-full max-w-sm transform -translate-x-full transition-transform duration-300 ease-in-out md:relative md:max-w-xs md:translate-x-0 lg:max-w-sm bg-gray-900 p-6 flex-shrink-0 overflow-y-auto">
            <div class="space-y-6">
                <header class="flex items-center justify-between">
                    <div><h1 class="text-2xl font-bold text-white">Galactic Star Map</h1><p id="welcome-message" class="text-sm text-gray-400"></p></div>
                    <div id="user-controls" class="flex space-x-2">
                        <a href="/guide.html" class="px-3 py-1 text-sm font-medium text-white bg-gray-600 rounded-md hover:bg-gray-700">Guide</a>
                        <button id="profile-button" class="px-3 py-1 text-sm font-medium text-white bg-gray-600 rounded-md hover:bg-gray-700">Profile</button>
                        <button id="logout-button" class="px-3 py-1 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700">Logout</button>
                    </div>
                </header>
                <div id="sync-container" class="border-t border-b border-gray-700 py-4 space-y-3">
                    <button id="sync-button" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md">Sync Map Data</button>
                    <p id="sync-status" class="text-sm text-center text-gray-400 mt-2 h-4" aria-live="assertive"></p>
                </div>
                <form id="route-form" class="space-y-4">
                    <div class="relative">
                        <label class="block text-xs text-gray-500 mb-1">Start</label>
                        <input type="text" id="start-system-input" list="system-list" class="route-input w-full bg-gray-700 border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-indigo-500" placeholder="Start System or #Pos...">
                    </div>

                    <div id="waypoints-container" class="space-y-2"></div>
                    
                    <button type="button" id="add-waypoint-btn" class="text-xs text-indigo-400 hover:text-indigo-300 flex items-center focus:outline-none">
                        <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                        Add Waypoint
                    </button>

                    <div class="relative">
                        <label class="block text-xs text-gray-500 mb-1">Destination</label>
                        <input type="text" id="end-system-input" list="system-list" class="route-input w-full bg-gray-700 border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-indigo-500" placeholder="End System or #Pos...">
                    </div>
                    
                    <datalist id="system-list"></datalist>
                    
                    <div class="space-y-2 pt-2 border-t border-gray-700">
                        <div class="flex items-center">
                            <input id="filter-avoid-slow" type="checkbox" class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-indigo-600 focus:ring-indigo-500">
                            <label for="filter-avoid-slow" class="ml-2 block text-sm text-gray-300">Avoid Slow Sublight Regions</label>
                        </div>
                        <div class="flex items-center">
                            <input id="filter-avoid-hostile" type="checkbox" class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-indigo-600 focus:ring-indigo-500">
                            <label for="filter-avoid-hostile" class="ml-2 block text-sm text-gray-300">Avoid Hostile Systems</label>
                        </div>
                    </div>
                    <button type="submit" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md">Find Shortest Path</button>
                </form>

                <div id="route-details" aria-live="polite" class="space-y-2"></div>
                
                <div class="border-t border-gray-700 pt-4 space-y-4">
                    <h3 class="text-lg font-semibold text-white">Search & Filters</h3>
                    <form id="search-form" class="space-y-2">
                        <input type="text" id="search-input" list="system-list" class="w-full bg-gray-700 border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-indigo-500" placeholder="Find & Center on System...">
                        <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md text-sm">Search</button>
                    </form>
                    <div class="space-y-2">
                         <div class="flex items-center">
                             <input id="filter-catapults" type="checkbox" checked class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-indigo-600 focus:ring-indigo-500">
                             <label for="filter-catapults" class="ml-2 block text-sm text-gray-300">Show Catapult Ranges</label>
                         </div>
                        <div class="flex items-center">
                             <input id="filter-wormholes" type="checkbox" checked class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-indigo-600 focus:ring-indigo-500">
                             <label for="filter-wormholes" class="ml-2 block text-sm text-gray-300">Show Wormholes</label>
                        </div>
                    </div>
                </div>

                <div class="border-t border-gray-700 pt-4 space-y-2" aria-hidden="true">
                    <h3 class="text-lg font-semibold text-white">Display Options</h3>
                    <div class="flex items-center">
                        <input id="toggle-unclaimed-names" type="checkbox" class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-indigo-600 focus:ring-indigo-500">
                        <label for="toggle-unclaimed-names" class="ml-2 block text-sm text-gray-300">Show Unclaimed Names</label>
                    </div>
                    <p class="text-xs text-gray-500">Click to select. Right-Click/Long-Press for Intel. Shift+Click to toggle range.</p>
                    <button id="reset-view-button" class="mt-2 w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md text-sm">Reset View</button>
                </div>
            </div>
        </aside>

        <main class="relative flex-grow flex items-center justify-center">
            <button id="menu-button" class="md:hidden absolute top-4 left-4 z-30 p-2 bg-gray-800 text-white rounded-md flex items-center space-x-2" title="Toggle Menu" aria-label="Toggle map controls panel" aria-controls="side-panel" aria-expanded="true">
                <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                <span class="text-sm">Toggle Controls</span>
            </button>
            <button id="center-me-button" class="absolute bottom-4 right-4 z-10 p-2 bg-gray-800 text-white rounded-full shadow-lg" title="Center on last known location">
                <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path d="M10 8a2 2 0 100-4 2 2 0 000 4z" /><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm0 2a10 10 0 100-20 10 10 0 000 20z" clip-rule="evenodd" /></svg>
            </button>
            <canvas id="map-canvas" class="w-full h-full"></canvas>
        </main>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        let systems = {}; let wormholes = []; 
        let calculatedPathNodes = []; 
        let calculatedPathLegs = [];  
        let viewTransform = { scale: 1, translateX: 0, translateY: 0 }; 
        let isMouseDown = false; let isDragging = false; let dragStartPos = { x: 0, y: 0 }; let lastDragPosition = {x:0, y:0};
        const SPIRAL_TIGHTNESS = 0.1; const SPIRAL_SCALE = 50;
        let toggledCatapultIds = new Set();
        let activeRouteInput = null;
        let hoveredSystem = null;
        let showUnclaimedNames = false;
        let highlightedCatapultSystemId = null;
        let longPressTimer; let initialTouchDistance = null;
        let newlySyncedSystemIds = new Set();
        let highlightedSearchSystemId = null;
        let filterShowCatapults = true;
        let filterShowWormholes = true;
        let showBulkSyncButton = false;
        let lastKnownSystemId = null; 
        
        let pingAnimation = null; 
        let isAnimatingPing = false; 
        let pingAnimationFrameId = null;
        
        // Intel State
        let intelMarkers = [];
        let pendingIntelCoords = null; 
        // --- END ---

        const dom = { 
            loginView: document.getElementById('login-view'), mapView: document.getElementById('map-view'), registerView: document.getElementById('register-view'), 
            loginForm: document.getElementById('login-form'), registerForm: document.getElementById('register-form'), profileView: document.getElementById('profile-view'), 
            canvas: document.getElementById('map-canvas'), ctx: document.getElementById('map-canvas').getContext('2d'), loginError: document.getElementById('login-error'), 
            logoutButton: document.getElementById('logout-button'), welcomeMessage: document.getElementById('welcome-message'), 
            syncContainer: document.getElementById('sync-container'), syncButton: document.getElementById('sync-button'), syncStatus: document.getElementById('sync-status'), 
            routeForm: document.getElementById('route-form'), startSystemInput: document.getElementById('start-system-input'), endSystemInput: document.getElementById('end-system-input'), 
            waypointsContainer: document.getElementById('waypoints-container'),
            addWaypointBtn: document.getElementById('add-waypoint-btn'),
            systemDataList: document.getElementById('system-list'), routeDetailsContainer: document.getElementById('route-details'), 
            profileButton: document.getElementById('profile-button'), closeProfileButton: document.getElementById('close-profile-button'), profileForm: document.getElementById('profile-form'), 
            apiKeyInput: document.getElementById('api-key-input'), newPasswordInput: document.getElementById('new-password-input'), profileStatus: document.getElementById('profile-status'), 
            registerError: document.getElementById('register-error'), showRegisterViewButton: document.getElementById('show-register-view-button'), showLoginViewButton: document.getElementById('show-login-view-button'), 
            userControls: document.getElementById('user-controls'), 
            resetViewButton: document.getElementById('reset-view-button'), toggleUnclaimedNames: document.getElementById('toggle-unclaimed-names'),
            sidePanel: document.getElementById('side-panel'),
            menuButton: document.getElementById('menu-button'),
            searchForm: document.getElementById('search-form'),
            searchInput: document.getElementById('search-input'),
            filterCatapults: document.getElementById('filter-catapults'),
            filterWormholes: document.getElementById('filter-wormholes'),
            filterAvoidSlow: document.getElementById('filter-avoid-slow'), 
            filterAvoidHostile: document.getElementById('filter-avoid-hostile'),
            bulkSyncButton: document.getElementById('bulk-sync-button'),
            bulkSyncText: document.getElementById('bulk-sync-text'),
            centerMeButton: document.getElementById('center-me-button'),
            // Intel Context Menu DOM
            intelContextMenu: document.getElementById('intel-context-menu'),
            intelMenuTitle: document.getElementById('intel-menu-title'),
            intelCoordsDisplay: document.getElementById('intel-coords-display'),
            intelTypeInput: document.getElementById('intel-type-input'),
            intelNoteInput: document.getElementById('intel-note-input'),
            cancelIntelBtn: document.getElementById('cancel-intel-btn'),
            saveIntelBtn: document.getElementById('save-intel-btn'),
            deleteIntelBtn: document.getElementById('delete-intel-btn')
        };

        const apiFetch = (url, options = {}) => { options.credentials = 'include'; return fetch(url, options); };
        const handleLogin = async (e) => { e.preventDefault(); const r=await apiFetch('/login',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({username:dom.loginForm.username.value,password:dom.loginForm.password.value})}); const d=await r.json(); if(r.ok)showMapView(d); else dom.loginError.textContent=d.message||'Login failed.'; };
        const handleRegister = async (e) => { e.preventDefault(); const p={username:dom.registerForm.username.value,password:dom.registerForm.password.value,api_key:dom.registerForm.api_key.value}; const r=await apiFetch('/register',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(p)}); const d=await r.json(); if(r.ok)showMapView(d, true); else dom.registerError.textContent=d.message||'Registration failed.'; };
        const handleLogout = async () => { await apiFetch('/logout', { method: 'POST' }); localStorage.removeItem('mapViewTransform'); showLoginView(); };
        const checkLoginStatus = async () => { const r=await apiFetch('/status'); const d=await r.json(); if(d.logged_in)showMapView(d); else showLoginView(); };
        
        const handleSync = async () => {
            const oldSystemIds = new Set(Object.keys(systems));
            dom.syncStatus.textContent = 'Syncing...'; 
            dom.syncButton.disabled = true; 
            try { 
                const r = await apiFetch('/api/sync', {method:'POST'}); 
                const d = await r.json(); 
                dom.syncStatus.textContent = d.message || d.error; 
                if (r.ok) {
                    const statusRes = await apiFetch('/status'); 
                    const statusData = await statusRes.json();
                    if (statusData.logged_in) {
                        lastKnownSystemId = statusData.last_known_system_id; 
                    }
                    await fetchMapData(false, oldSystemIds);
                } else {
                    console.error("Sync failed:", d.error || `Status ${r.status}`);
                }
            } catch (e) { 
                dom.syncStatus.textContent = 'Error: Could not connect to server.'; 
                console.error("Sync connection error:", e);
            } finally { 
                dom.syncButton.disabled = false; 
                setTimeout(() => { dom.syncStatus.textContent = ''; }, 7000); 
            } 
        };

        const handleBulkSync = async (e) => {
            e.preventDefault();
            dom.profileStatus.textContent = 'Importing... this may take a moment.';
            dom.bulkSyncButton.disabled = true;
            try {
                const r = await apiFetch('/api/bulk_sync_faction_systems', {method: 'POST'});
                const d = await r.json();
                if (!r.ok) throw new Error(d.error || 'Failed to import.');
                
                dom.profileStatus.textContent = d.message;
                showBulkSyncButton = false;
                dom.bulkSyncButton.classList.add('hidden');
                dom.bulkSyncText.classList.add('hidden');
                await fetchMapData(false);
                setTimeout(closeProfile, 2000);

            } catch (e) {
                dom.profileStatus.textContent = `Error: ${e.message}`;
                dom.bulkSyncButton.disabled = false;
            }
        };

        const openProfile = async () => { 
            dom.profileStatus.textContent = ''; 
            dom.newPasswordInput.value = ''; 
            try {
                const r = await apiFetch('/api/profile'); 
                if (!r.ok) throw new Error(`Failed to load profile: ${r.statusText}`);
                const d = await r.json(); 
                dom.apiKeyInput.value = d.api_key_set ? '(Key is set and encrypted)' : ''; 
                dom.apiKeyInput.placeholder = d.api_key_set ? 'Enter a new key to overwrite' : 'Enter your game API key'; 
                
                if (showBulkSyncButton) {
                    dom.bulkSyncButton.classList.remove('hidden');
                    dom.bulkSyncText.classList.remove('hidden');
                    dom.bulkSyncButton.disabled = false;
                } else {
                    dom.bulkSyncButton.classList.add('hidden');
                    dom.bulkSyncText.classList.add('hidden');
                }
                dom.profileView.classList.remove('hidden'); 
            } catch (error) {
                 dom.profileStatus.textContent = `Error: ${error.message}`;
                 console.error("Profile load error:", error);
            }
        };
        const closeProfile = () => dom.profileView.classList.add('hidden');
        const handleProfileUpdate = async (e) => { e.preventDefault(); dom.profileStatus.textContent = 'Saving...'; const p={}; if (dom.apiKeyInput.value && dom.apiKeyInput.value !== '(Key is set and encrypted)') p.api_key = dom.apiKeyInput.value; if (dom.newPasswordInput.value) p.password = dom.newPasswordInput.value; try { const r=await apiFetch('/api/profile',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(p)}); if (!r.ok) throw new Error(`Save failed: ${r.statusText}`); const d=await r.json(); dom.profileStatus.textContent = d.message; setTimeout(closeProfile, 2000); } catch(error) { dom.profileStatus.textContent = `Error: ${error.message}`; console.error("Profile update error:", error); } };
        
        async function fetchMapData(shouldFit = true, oldSystemIds = null) { 
            try {
                // Parallel fetch
                const [systemsRes, intelRes] = await Promise.all([
                    apiFetch('/api/systems'),
                    apiFetch('/api/intel')
                ]);

                if (!systemsRes.ok) { if (systemsRes.status === 401) handleLogout(); else throw new Error(`Failed to load systems: ${systemsRes.statusText}`); return; } 
                
                const d = await systemsRes.json(); 
                systems = d.systems; 
                wormholes = d.wormholes; 

                if (intelRes.ok) {
                    intelMarkers = await intelRes.json();
                } else {
                    console.error("Failed to load intel markers");
                }

                populateDataList(); 
                if (shouldFit) { fitMapToView(); }
                
                if (oldSystemIds) {
                    newlySyncedSystemIds.clear();
                    Object.keys(systems).forEach(id => {
                        if (!oldSystemIds.has(id)) {
                            newlySyncedSystemIds.add(id);
                        }
                    });
                    if (newlySyncedSystemIds.size > 0) {
                        setTimeout(() => {
                            newlySyncedSystemIds.clear();
                            drawMap();
                        }, 2000);
                    }
                }
                drawMap();
            } catch (e) { console.error("Failed to fetch or draw map data:", e); } 
        }
        
        function addWaypointInput() {
            const container = dom.waypointsContainer;
            const div = document.createElement('div');
            div.className = 'relative flex items-center space-x-2';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'route-input w-full bg-gray-700 border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-indigo-500';
            input.placeholder = 'Waypoint...';
            input.setAttribute('list', 'system-list');
            
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'text-red-400 hover:text-red-300';
            removeBtn.innerHTML = '&times;';
            removeBtn.title = 'Remove Waypoint';
            removeBtn.onclick = () => div.remove();

            div.appendChild(input);
            div.appendChild(removeBtn);
            container.appendChild(div);
            
            input.addEventListener('focus', () => { activeRouteInput = input; });
        }

        async function findPath() {
            const startVal = dom.startSystemInput.value.trim();
            const endVal = dom.endSystemInput.value.trim();
            
            const waypoints = [];
            dom.waypointsContainer.querySelectorAll('input').forEach(input => {
                const val = input.value.trim();
                if (val) waypoints.push(val);
            });

            if (!startVal || !endVal) {
                 dom.routeDetailsContainer.innerHTML = `<p class="text-red-400">Please define at least Start and Destination.</p>`;
                 return;
            }

            const routeStops = [startVal, ...waypoints, endVal];
            const avoidSlow = dom.filterAvoidSlow.checked;
            const avoidHostile = dom.filterAvoidHostile.checked;
            
            dom.routeDetailsContainer.innerHTML = '<p class="text-gray-400">Calculating route...</p>';
            
            try {
                let totalDist = 0;
                let combinedPathNodes = [];
                let combinedDetailedPath = [];
                
                const parseInput = (val) => {
                     if (val.match(/^#\d+(\.\d+)?$/)) { 
                         const pos = parseFloat(val.substring(1)); 
                         return !isNaN(pos) ? `pos:${pos}` : null; 
                     }
                     const system = Object.values(systems).find(s => 
                         (s.name && s.name.toLowerCase() === val.toLowerCase()) || 
                         (s.position && `#${s.position}` === val)
                     );
                     return system ? `sys:${system.id}` : null;
                };

                const requests = [];
                for (let i = 0; i < routeStops.length - 1; i++) {
                    const sId = parseInput(routeStops[i]);
                    const eId = parseInput(routeStops[i+1]);
                    
                    if (!sId || !eId) throw new Error(`Invalid system: ${!sId ? routeStops[i] : routeStops[i+1]}`);
                    
                    requests.push(apiFetch('/api/path', { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ 
                            start_id: sId, 
                            end_id: eId,
                            avoid_slow_regions: avoidSlow,
                            avoid_hostile: avoidHostile
                        })
                    }));
                }

                const responses = await Promise.all(requests);
                
                for (const r of responses) {
                    const d = await r.json();
                    if (!r.ok) throw new Error(d.error || `Calculation failed`);
                    
                    if (d.distance === null) {
                        throw new Error("No path found for one or more segments.");
                    }

                    totalDist += d.distance;
                    combinedPathNodes = combinedPathNodes.concat(d.path);
                    combinedDetailedPath = combinedDetailedPath.concat(d.detailed_path);
                }
                
                const finalResult = {
                    distance: totalDist,
                    path: combinedPathNodes,
                    detailed_path: combinedDetailedPath
                };
                
                displayPathResults(finalResult, routeStops);

            } catch (error) {
                 console.error("Pathfinding error:", error);
                 dom.routeDetailsContainer.innerHTML = `<p class="text-red-400">Error: ${error.message}</p>`;
            }
        }

        function showLoginView() { dom.mapView.classList.add('hidden'); dom.registerView.classList.add('hidden'); dom.loginView.classList.remove('hidden'); }
        function showRegisterView() { dom.mapView.classList.add('hidden'); dom.loginView.classList.add('hidden'); dom.registerView.classList.remove('hidden'); }
        
        function showMapView(data, isNewRegistration = false) {
            dom.loginView.classList.add('hidden'); dom.registerView.classList.add('hidden'); dom.mapView.classList.remove('hidden');
            dom.welcomeMessage.textContent = `Welcome, ${data.username}`;
            showBulkSyncButton = data.show_bulk_sync || false;
            lastKnownSystemId = data.last_known_system_id || null; 

            let adminBtn = document.getElementById('admin-button');
            if (data.is_admin && !adminBtn) { adminBtn = document.createElement('a'); adminBtn.id = 'admin-button'; adminBtn.href = '/admin'; adminBtn.textContent = 'Admin'; adminBtn.className = 'px-3 py-1 text-sm font-medium text-white bg-purple-600 rounded-md hover:bg-purple-700'; dom.userControls.prepend(adminBtn); } 
            else if (!data.is_admin && adminBtn) { adminBtn.remove(); }
            if (data.is_developer) { dom.syncContainer.classList.add('hidden'); } else { dom.syncContainer.classList.remove('hidden'); }
            
            resizeCanvas(); 

            if (!isNewRegistration) {
                const savedView = localStorage.getItem('mapViewTransform');
                if (savedView) { 
                    try { viewTransform = JSON.parse(savedView); } catch { /* Ignore parse error */ }
                }
                fetchMapData(savedView ? false : true); 
            } else {
                fetchMapData(true); 
            }
        }
        function populateDataList() {
            dom.systemDataList.innerHTML = '';
            const options = new Set();
            Object.values(systems).forEach(s => {
                if (s.name) options.add(s.name);
                if (s.position) options.add(`#${s.position}`); 
            });
            Array.from(options).sort().forEach(val => { const o = document.createElement('option'); o.value = val; dom.systemDataList.appendChild(o); });
        }
        
        function displayPathResults(result, routeStopsInput = []) {
            dom.routeDetailsContainer.innerHTML = ''; 
            calculatedPathNodes = result.path || []; 
            calculatedPathLegs = result.detailed_path || []; 

            const allNodes = {};
            calculatedPathNodes.forEach(p => allNodes[p.id] = p);
            
            const startInputVal = dom.startSystemInput.value || (allNodes[calculatedPathLegs?.[0]?.from_id]?.name || 'Start');
            const endInputVal = dom.endSystemInput.value || (allNodes[calculatedPathLegs?.[calculatedPathLegs.length - 1]?.to_id]?.name || 'End');

            dom.startSystemInput.value = '';
            dom.endSystemInput.value = '';
            
            if (calculatedPathLegs.length > 0 && result.distance != null) {
                const counts = { sublight: 0, catapult: 0, catapult_sublight: 0, wormhole: 0 };
                calculatedPathLegs.forEach(leg => {
                    if (counts[leg.method] !== undefined) {
                        counts[leg.method]++;
                    } else {
                        counts.sublight++; 
                    }
                });

                const summaryParts = [];
                if (counts.catapult > 0) summaryParts.push(`${counts.catapult} Catapult`);
                if (counts.catapult_sublight > 0) summaryParts.push(`${counts.catapult_sublight} Catapult+Sublight`);
                if (counts.wormhole > 0) summaryParts.push(`${counts.wormhole} Wormhole`);
                if (counts.sublight > 0) summaryParts.push(`${counts.sublight} Sublight`);
                
                const summaryString = `<strong>Total Jumps: ${calculatedPathLegs.length}</strong> (${summaryParts.join(', ')})`;

                let titleText = "Route";
                if (routeStopsInput.length > 0) {
                    titleText = `Route: ${routeStopsInput[0]} &rarr; ${routeStopsInput[routeStopsInput.length-1]}`;
                }

                let html = `<div class="flex justify-between items-center"><h2 class="text-lg font-semibold text-white truncate" title="${titleText}">${titleText}</h2><button id="clear-route-button" class="text-sm text-gray-400 hover:text-white focus:outline-none whitespace-nowrap ml-2">&times; Clear</button></div>`;
                html += `<p class="text-sm text-gray-400">Total Distance: ${result.distance.toFixed(2)}</p>`;
                html += `<p class="text-xs text-gray-500 mb-2">${summaryString}</p>`; 
                html += `<ol class="mt-2 space-y-2 text-sm max-h-60 overflow-y-auto pr-2">`;
                
                const getDisplayName = (node) => {
                    if (!node) return 'Unknown';
                    if (node.id.toString().startsWith('virtual') || (node.name.startsWith("System ") && node.position)) {
                        return `#${node.position}`;
                    }
                    return node.name;
                };

                if (calculatedPathLegs.length > 0) {
                     const firstLeg = calculatedPathLegs[0];
                     const startNode = allNodes[firstLeg.from_id];
                     html += `<li class="text-gray-300">1. Start at: <span class="font-semibold text-white">${getDisplayName(startNode)}</span></li>`;
                }
                
                calculatedPathLegs.forEach((leg, index) => { 
                    let travelMethod = leg.method.charAt(0).toUpperCase() + leg.method.slice(1); 
                    let color = 'text-amber-400'; 
                    
                    if (leg.method === 'wormhole') {
                        color = 'text-red-400'; 
                        travelMethod = 'Wormhole';
                    } else if (leg.method === 'catapult') {
                        color = 'text-lime-400'; 
                        travelMethod = 'Catapult';
                    } else if (leg.method === 'catapult_sublight') { 
                        color = 'text-lime-400'; 
                        travelMethod = 'Catapult + Sublight';
                    } else {
                        travelMethod = 'Sublight';
                    }

                    const toNode = allNodes[leg.to_id];
                    html += `<li class="text-gray-300">${index + 2}. <span class="font-semibold ${color}">${travelMethod}</span> to <span class="font-semibold text-white">${getDisplayName(toNode)}</span></li>`; 
                });
                html += `</ol>`; 
                dom.routeDetailsContainer.innerHTML = html;
            } else { 
                dom.routeDetailsContainer.innerHTML = `<h2 class="text-lg font-semibold text-white">No Route Found</h2><p class="text-yellow-400">A path could not be found. Check inputs or adjust filters.</p>`; 
            }
            drawMap(); 
        }

        function toggleSidePanel() {
            const isExpanded = dom.menuButton.getAttribute('aria-expanded') === 'true';
            dom.sidePanel.classList.toggle('-translate-x-full');
            dom.menuButton.setAttribute('aria-expanded', !isExpanded);
        }
        
        function animatePing() {
            isAnimatingPing = true;
            
            if (!pingAnimation) {
                 isAnimatingPing = false;
                 pingAnimationFrameId = null;
                 drawMap(); 
                 return;
            }

            const elapsed = Date.now() - pingAnimation.startTime;
            
            if (elapsed > pingAnimation.duration) {
                pingAnimation = null;
                isAnimatingPing = false;
                pingAnimationFrameId = null;
                drawMap(); 
                return;
            }
            
            drawMap(); 
            pingAnimationFrameId = requestAnimationFrame(animatePing); 
        }

        function centerOnMyLocation() {
            if (!lastKnownSystemId) {
                alert("No location known. Please sync your data first.");
                return;
            }
            const targetSystem = systems[lastKnownSystemId];
            if (!targetSystem) {
                alert("Your last known location is not in the discovered map. Please sync again.");
                return;
            }
            
            viewTransform.scale = 1.0; 
            viewTransform.translateX = (dom.canvas.width / 2) - (targetSystem.x * viewTransform.scale);
            viewTransform.translateY = (dom.canvas.height / 2) - (targetSystem.y * viewTransform.scale);
            
            drawMap(); 
            localStorage.setItem('mapViewTransform', JSON.stringify(viewTransform));
            highlightedSearchSystemId = null; 
            
            if (isAnimatingPing && pingAnimationFrameId) {
                cancelAnimationFrame(pingAnimationFrameId);
            }
            pingAnimation = null;
            isAnimatingPing = false;
            pingAnimationFrameId = null;

            pingAnimation = { systemId: lastKnownSystemId, startTime: Date.now(), duration: 1200 };
            animatePing(); 
        }

        function clearRouteDisplay() { 
            calculatedPathNodes = []; 
            calculatedPathLegs = []; 
            dom.routeDetailsContainer.innerHTML = ''; 
            dom.startSystemInput.value = '';
            dom.endSystemInput.value = '';
            dom.waypointsContainer.innerHTML = '';
            drawMap(); 
        } 
        function resizeCanvas() { if(dom.canvas.parentElement.clientWidth > 0){ dom.canvas.width = dom.canvas.clientWidth; dom.canvas.height = dom.canvas.clientHeight; if(dom.canvas.width > 0) drawMap(); } }
        function fitMapToView() { if (Object.keys(systems).length === 0) return; let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity; Object.values(systems).forEach(s => { if (typeof s.x === 'number' && typeof s.y === 'number'){ minX=Math.min(minX,s.x); maxX=Math.max(maxX,s.x); minY=Math.min(minY,s.y); maxY=Math.max(maxY,s.y); }}); if (!isFinite(minX)) return; const mapW=maxX-minX || 1, mapH=maxY-minY || 1; const mapCX=minX+mapW/2, mapCY=minY+mapH/2; const scale=Math.min(dom.canvas.width/(mapW*1.2), dom.canvas.height/(mapH*1.2))||1; viewTransform = { scale, translateX: (dom.canvas.width/2)-(mapCX*scale), translateY: (dom.canvas.height/2)-(mapCY*scale) }; localStorage.setItem('mapViewTransform', JSON.stringify(viewTransform));}
        const getSpiralPoint = (pos) => { const a=SPIRAL_TIGHTNESS, r=parseFloat(pos)*SPIRAL_SCALE/1000; return { x: r*Math.cos(parseFloat(pos)*a), y: r*Math.sin(parseFloat(pos)*a) }; }; 

        function drawSublight(posA, posB) {
            if (isNaN(posA) || isNaN(posB)) return;
            const ctx = dom.ctx; 
            ctx.strokeStyle = '#f59e0b'; 
            ctx.lineWidth = 3 / viewTransform.scale;
            const s = 1; 
            ctx.beginPath(); 
            const startPoint = getSpiralPoint(posA);
            ctx.moveTo(startPoint.x, startPoint.y); 
            const dist = Math.abs(posB - posA);
            const sign = Math.sign(posB - posA);
            for (let j = 1; j <= Math.floor(dist / s); j++) {
                const p = posA + (j * s * sign);
                const point = getSpiralPoint(p);
                ctx.lineTo(point.x, point.y);
            } 
            const endPoint = getSpiralPoint(posB);
            ctx.lineTo(endPoint.x, endPoint.y);
            ctx.stroke();
        }
        
        function drawMap() {
            if(!dom.canvas.width || !dom.ctx) return; const ctx = dom.ctx;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0,0,dom.canvas.width,dom.canvas.height);
            ctx.save();
            ctx.translate(viewTransform.translateX, viewTransform.translateY);
            ctx.scale(viewTransform.scale, viewTransform.scale);
            
            const systemPositions = Object.values(systems).map(s => parseFloat(s.position)).filter(p => !isNaN(p));
            if(systemPositions.length > 0){ let maxPos=Math.max(...systemPositions); if(maxPos>0){ ctx.strokeStyle='rgba(75,85,99,0.2)';ctx.lineWidth=1/viewTransform.scale;ctx.beginPath();const s=1;ctx.moveTo(0,0);for(let p=s;p<=maxPos*1.1;p+=s)ctx.lineTo(getSpiralPoint(p).x,getSpiralPoint(p).y);ctx.stroke();}}
            
            if (filterShowCatapults) {
                Object.values(systems).forEach(sys => { 
                    const sysPos = parseFloat(sys.position);
                    const sysRadius = parseFloat(sys.catapult_radius);
                    if (isNaN(sysPos) || isNaN(sysRadius) || sysRadius <= 0) return;
                    const isToggled = toggledCatapultIds.has(String(sys.id));
                    if (!isToggled) { 
                        let rangeColor = 'rgba(132, 204, 22, 0.3)';
                        if (highlightedCatapultSystemId !== null) { rangeColor = (sys.id === highlightedCatapultSystemId) ? 'rgba(163, 230, 57, 0.9)' : 'rgba(132, 204, 22, 0.05)'; }
                        ctx.strokeStyle = rangeColor; ctx.lineWidth = 2 / viewTransform.scale;
                        const startPos = sysPos - sysRadius; const endPos = sysPos + sysRadius;
                        const step = 1; 
                        ctx.beginPath(); ctx.moveTo(getSpiralPoint(startPos).x, getSpiralPoint(startPos).y);
                        for (let pos = startPos + step; pos < endPos; pos += step) { ctx.lineTo(getSpiralPoint(pos).x, getSpiralPoint(pos).y); }
                        ctx.lineTo(getSpiralPoint(endPos).x, getSpiralPoint(endPos).y); ctx.stroke();
                    }
                });
            }

            if (filterShowWormholes) {
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.4)'; ctx.lineWidth = 1 / viewTransform.scale; ctx.setLineDash([5 / viewTransform.scale, 5 / viewTransform.scale]);
                wormholes.forEach(wh => { const sA=systems[wh[0]], sB=systems[wh[1]]; if (sA && sB && typeof sA.x === 'number' && typeof sB.x === 'number') { ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke(); } });
                ctx.setLineDash([]);
            }
            
            const calculatedPathIds = new Set(calculatedPathNodes.map(p => p.id));
            if (calculatedPathLegs.length > 0) {
                const nodeMap = new Map(calculatedPathNodes.map(n => [n.id, n]));
                calculatedPathLegs.forEach(leg => {
                    const sA = nodeMap.get(leg.from_id);
                    const sB = nodeMap.get(leg.to_id);
                    if (!sA || !sB) return; 
                    const posA = parseFloat(sA.position); 
                    const posB = parseFloat(sB.position);
                    if (isNaN(posA) || isNaN(posB)) return;
                    if (leg.method === 'wormhole') { 
                        ctx.strokeStyle='#ef4444'; ctx.lineWidth=3/viewTransform.scale; 
                        ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke(); 
                    } else if (leg.method === 'catapult') { 
                        ctx.strokeStyle='#a3e635'; ctx.lineWidth=3/viewTransform.scale; 
                        ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke(); 
                    } else if (leg.method === 'catapult_sublight') {
                        const catapultRadius = systems[sA.id]?.catapult_radius || 0;
                        const sign = Math.sign(posB - posA);
                        const virtualNodePos = posA + (sign * catapultRadius);
                        const coordsA = { x: sA.x, y: sA.y };
                        const coordsV = getSpiralPoint(virtualNodePos);
                        ctx.strokeStyle = '#a3e635'; 
                        ctx.lineWidth = 3 / viewTransform.scale; 
                        ctx.beginPath(); 
                        ctx.moveTo(coordsA.x, coordsA.y); 
                        ctx.lineTo(coordsV.x, coordsV.y); 
                        ctx.stroke();
                        drawSublight(virtualNodePos, posB);
                        ctx.fillStyle = '#f59e0b'; 
                        ctx.strokeStyle = '#1f2937'; 
                        ctx.lineWidth = 1 / viewTransform.scale;
                        ctx.beginPath();
                        ctx.arc(coordsV.x, coordsV.y, 3 / viewTransform.scale, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else { 
                        drawSublight(posA, posB); 
                    }
                });
            }
            
            Object.values(systems).forEach(sys => {
                if (typeof sys.x !== 'number' || typeof sys.y !== 'number') { return; }
                const isOnPath = calculatedPathIds.has(String(sys.id));
                const isHovered = hoveredSystem && hoveredSystem.id === sys.id;
                const isNewlySynced = newlySyncedSystemIds.has(String(sys.id));
                const isSearched = highlightedSearchSystemId === sys.id;
                
                ctx.fillStyle = isOnPath || isSearched ? '#f59e0b' : '#38bdf8';
                ctx.beginPath();
                ctx.arc(sys.x, sys.y, (isOnPath || isHovered || isSearched ? 6 : 4) / viewTransform.scale, 0, Math.PI * 2);
                ctx.fill();
                if (isNewlySynced) {
                    ctx.strokeStyle = 'rgba(250, 204, 21, 0.9)';
                    ctx.lineWidth = 3 / viewTransform.scale;
                    ctx.stroke();
                }
            });

            calculatedPathNodes.forEach(node => {
                if (node.id.toString().startsWith('virtual')) {
                    const size = 8 / viewTransform.scale;
                    ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2 / viewTransform.scale;
                    ctx.beginPath();
                    ctx.moveTo(node.x - size, node.y - size); ctx.lineTo(node.x + size, node.y + size);
                    ctx.moveTo(node.x + size, node.y - size); ctx.lineTo(node.x - size, node.y + size);
                    ctx.stroke();
                }
            });

            Object.values(systems).forEach(sys => {
                if (typeof sys.x !== 'number' || typeof sys.y !== 'number') return;
                const isOnPath = calculatedPathIds.has(String(sys.id));
                const isHovered = hoveredSystem && hoveredSystem.id === sys.id;
                const isSearched = highlightedSearchSystemId === sys.id;
                let labelText = sys.name;
                const isDefaultName = labelText && labelText.startsWith("System ");
                if (isDefaultName && typeof sys.position === 'string' && sys.position !== '') { 
                    labelText = `#${sys.position}`; 
                } else if (!labelText) {
                    labelText = `ID: ${sys.id}`; 
                }
                let shouldShowLabel = (isOnPath || isHovered || isSearched || viewTransform.scale > 0.8);
                if (isDefaultName && !showUnclaimedNames && !isOnPath && !isHovered && !isSearched) { 
                    shouldShowLabel = false; 
                }
                if (shouldShowLabel) {
                    ctx.fillStyle = (isOnPath || isHovered || isSearched) ? '#ffffff' : '#e5e7eb';
                    ctx.font = `${(isOnPath || isHovered || isSearched ? 12 : 10) / viewTransform.scale}px Inter`;
                    ctx.textAlign = 'center';
                    ctx.fillText(labelText, sys.x, sys.y - ((isOnPath || isHovered || isSearched ? 10 : 8) / viewTransform.scale));
                }
            });

            calculatedPathNodes.forEach(node => {
                if (node.id.toString().startsWith('virtual')) {
                    const size = 8 / viewTransform.scale;
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${12 / viewTransform.scale}px Inter`;
                    ctx.textAlign = 'center';
                    ctx.fillText(node.name, node.x, node.y - (size + 4 / viewTransform.scale));
                }
            });

            if (pingAnimation && systems[pingAnimation.systemId]) {
                const sys = systems[pingAnimation.systemId];
                if (typeof sys.x === 'number' && typeof sys.y === 'number') { 
                    const elapsed = Date.now() - pingAnimation.startTime;
                    const progress = elapsed / pingAnimation.duration; 
                    const maxRadius = (Math.max(dom.canvas.width, dom.canvas.height) / 2) / viewTransform.scale;
                    const currentRadius = Math.max(0, maxRadius * (1 - progress)); 
                    const currentAlpha = Math.max(0, 1 - (progress * 0.8)); 
                    if (currentRadius > 0 && currentAlpha > 0) { 
                        ctx.strokeStyle = `rgba(245, 158, 11, ${currentAlpha})`; 
                        ctx.lineWidth = 4 / viewTransform.scale;
                        ctx.beginPath();
                        ctx.arc(sys.x, sys.y, currentRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    const delay = 150; 
                    if (elapsed > delay) {
                        const progress2 = (elapsed - delay) / (pingAnimation.duration - delay);
                        const currentRadius2 = Math.max(0, maxRadius * (1 - progress2));
                        const currentAlpha2 = Math.max(0, 1 - (progress2 * 0.8));
                        if (currentRadius2 > 0 && currentAlpha2 > 0) { 
                            ctx.lineWidth = 2 / viewTransform.scale; 
                            ctx.strokeStyle = `rgba(245, 158, 11, ${currentAlpha2})`; 
                            ctx.beginPath();
                            ctx.arc(sys.x, sys.y, currentRadius2, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                }
            }

            // Intel Markers
            intelMarkers.forEach(marker => {
                if (typeof marker.x === 'number' && typeof marker.y === 'number') {
                    const x = marker.x;
                    const y = marker.y;
                    ctx.save();
                    ctx.translate(x, y);
                    const size = Math.max(6, 12 / viewTransform.scale); 
                    
                    if (marker.type === "Mining Rich") {
                        ctx.fillStyle = '#22d3ee'; 
                        ctx.fillRect(-size/2, -size/2, size, size);
                    } else if (marker.type === "Hazard") {
                        ctx.fillStyle = '#fb923c'; 
                        ctx.beginPath();
                        ctx.moveTo(0, -size/2);
                        ctx.lineTo(size/2, size/2);
                        ctx.lineTo(-size/2, size/2);
                        ctx.closePath();
                        ctx.fill();
                    } else if (marker.type === "Point of Interest") {
                        ctx.fillStyle = '#c084fc'; 
                        ctx.beginPath();
                        ctx.arc(0, 0, size/2, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                }
            });
            
            ctx.restore();
        }

        // --- NEW: Context Menu Logic ---
        function openContextMenu(x, y, worldX, worldY, existingMarker = null) {
            dom.intelContextMenu.classList.add('hidden');
            
            // Keep menu on screen
            const menuWidth = 200;
            const menuHeight = 250;
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            
            let left = x;
            let top = y;
            
            if (left + menuWidth > screenW) left = screenW - menuWidth - 10;
            if (top + menuHeight > screenH) top = screenH - menuHeight - 10;

            dom.intelContextMenu.style.left = `${left}px`;
            dom.intelContextMenu.style.top = `${top}px`;
            
            if (existingMarker) {
                // VIEW/DELETE MODE
                dom.pendingIntelCoords = existingMarker; // Store the full object
                document.getElementById('intel-menu-title').textContent = "Intel Details";
                dom.intelTypeInput.value = existingMarker.type;
                dom.intelTypeInput.disabled = true;
                dom.intelNoteInput.value = existingMarker.note || "";
                dom.intelNoteInput.disabled = true; // Read-only
                
                dom.intelCoordsDisplay.textContent = `Coordinates: ${existingMarker.x.toFixed(0)}, ${existingMarker.y.toFixed(0)}`;
                
                dom.deleteIntelBtn.classList.remove('hidden'); // Show Delete
                dom.saveIntelBtn.classList.add('hidden');      // Hide Save
                
            } else {
                // ADD MODE
                dom.pendingIntelCoords = { x: worldX, y: worldY };
                document.getElementById('intel-menu-title').textContent = "Add Intel Marker";
                dom.intelTypeInput.disabled = false;
                dom.intelNoteInput.disabled = false;
                
                // Try to find nearest system for context
                let nearestSys = null;
                let nearestDist = Infinity;
                Object.values(systems).forEach(s => {
                    const dx = worldX - s.x;
                    const dy = worldY - s.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if(dist < nearestDist) { nearestDist = dist; nearestSys = s; }
                });
                
                let coordText = `Coordinates: ${worldX.toFixed(0)}, ${worldY.toFixed(0)}`;
                if (nearestSys && nearestDist < (10 / viewTransform.scale)) {
                    dom.pendingIntelCoords.system_id = nearestSys.id;
                    coordText += ` (Near ${nearestSys.name})`;
                } else {
                    delete dom.pendingIntelCoords.system_id;
                }
                dom.intelCoordsDisplay.textContent = coordText;
                dom.intelNoteInput.value = ''; 
                
                dom.deleteIntelBtn.classList.add('hidden'); // Hide Delete
                dom.saveIntelBtn.classList.remove('hidden'); // Show Save
            }
            
            dom.intelContextMenu.classList.remove('hidden');
        }
        
        function closeContextMenu() {
            dom.intelContextMenu.classList.add('hidden');
            dom.pendingIntelCoords = null;
        }
        
        async function saveIntelMarker() {
            if (!dom.pendingIntelCoords) return;
            const type = dom.intelTypeInput.value;
            const note = dom.intelNoteInput.value;
            try {
                const r = await apiFetch('/api/intel', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        x: dom.pendingIntelCoords.x,
                        y: dom.pendingIntelCoords.y,
                        system_id: dom.pendingIntelCoords.system_id,
                        type: type,
                        note: note
                    })
                });
                if (r.ok) {
                    closeContextMenu();
                    fetchMapData(false); 
                } else {
                    const d = await r.json();
                    alert("Failed to save marker: " + (d.error || "Unknown error"));
                }
            } catch (e) {
                console.error("Error saving intel:", e);
            }
        }

        // --- NEW: Delete Function ---
        async function deleteIntelMarker() {
            if (!dom.pendingIntelCoords || !dom.pendingIntelCoords.id) return;
            if (!confirm("Are you sure you want to delete this marker?")) return;

            try {
                const r = await apiFetch('/api/intel', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: dom.pendingIntelCoords.id })
                });

                if (r.ok) {
                    closeContextMenu();
                    fetchMapData(false);
                } else {
                    const d = await r.json();
                    alert("Failed to delete: " + (d.error || "Unknown error"));
                }
            } catch (e) {
                console.error("Error deleting intel:", e);
            }
        }
        
        dom.cancelIntelBtn.addEventListener('click', closeContextMenu);
        dom.saveIntelBtn.addEventListener('click', saveIntelMarker);
        dom.deleteIntelBtn.addEventListener('click', deleteIntelMarker);

        function handleToggleUnclaimedNames(e) { showUnclaimedNames = e.target.checked; drawMap(); }
        function handleResetView() { fitMapToView(); drawMap(); }

        function getEventCoordinates(e) {
            const rect = dom.canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function onInteractionStart(e) {
            if (!dom.intelContextMenu.classList.contains('hidden') && !dom.intelContextMenu.contains(e.target)) {
                 closeContextMenu();
            }

            isMouseDown = true; isDragging = false;
            const coords = getEventCoordinates(e);
            dragStartPos = { x: coords.x, y: coords.y };
            lastDragPosition = { x: coords.x, y: coords.y };
            
            clearTimeout(longPressTimer);
            longPressTimer = setTimeout(() => {
                if (!isDragging) {
                    // Check for system range toggle first
                    if (hoveredSystem && hoveredSystem.catapult_radius > 0) {
                        const systemId = String(hoveredSystem.id);
                        if (toggledCatapultIds.has(systemId)) { toggledCatapultIds.delete(systemId); } 
                        else { toggledCatapultIds.add(systemId); }
                        drawMap();
                    } else {
                         // Long Press for Context Menu
                         const worldX = (coords.x - viewTransform.translateX) / viewTransform.scale;
                         const worldY = (coords.y - viewTransform.translateY) / viewTransform.scale;
                         
                         // Check if clicked on existing marker
                         let clickedMarker = null;
                         for (const marker of intelMarkers) {
                             const dx = worldX - marker.x;
                             const dy = worldY - marker.y;
                             if (Math.sqrt(dx*dx + dy*dy) < (15 / viewTransform.scale)) { // Hitbox
                                 clickedMarker = marker;
                                 break;
                             }
                         }
                         openContextMenu(coords.x, coords.y, worldX, worldY, clickedMarker);
                    }
                }
            }, 500);
        }

        function onInteractionMove(e) {
             if (isDragging || (e.touches && e.touches.length > 1)) {
                 e.preventDefault();
             }

            const coords = getEventCoordinates(e);
            const worldX = (coords.x - viewTransform.translateX) / viewTransform.scale;
            const worldY = (coords.y - viewTransform.translateY) / viewTransform.scale;
            
            let currentlyHovering = null;
            let minDistSq = Math.pow(10 / viewTransform.scale, 2);
            for (const system of Object.values(systems)) {
                if (typeof system.x !== 'number' || typeof system.y !== 'number') continue;
                const dx = worldX - system.x; const dy = worldY - system.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < minDistSq) {
                     minDistSq = distSq;
                     currentlyHovering = system; 
                }
            }
            if (hoveredSystem !== currentlyHovering) { hoveredSystem = currentlyHovering; drawMap(); }

            if (e.touches && e.touches.length === 2) {
                isDragging = false; 
                clearTimeout(longPressTimer); 
                const t1 = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                const t2 = { x: e.touches[1].clientX, y: e.touches[1].clientY };
                const dist = Math.hypot(t1.x - t2.x, t1.y - t2.y);
                if (initialTouchDistance) {
                    const scaleFactor = dist / initialTouchDistance;
                    const rect = dom.canvas.getBoundingClientRect();
                    const midX = (t1.x + t2.x) / 2 - rect.left; 
                    const midY = (t1.y + t2.y) / 2 - rect.top;
                    const worldMidX = (midX - viewTransform.translateX) / viewTransform.scale;
                    const worldMidY = (midY - viewTransform.translateY) / viewTransform.scale;
                    viewTransform.scale *= scaleFactor;
                    viewTransform.scale = Math.max(0.05, Math.min(viewTransform.scale, 10)); 
                    viewTransform.translateX = midX - worldMidX * viewTransform.scale;
                    viewTransform.translateY = midY - worldMidY * viewTransform.scale;
                    drawMap();
                }
                initialTouchDistance = dist;
                return;
            } else {
                 initialTouchDistance = null; 
            }
            
            let cursorStyle = hoveredSystem ? 'pointer' : 'grab';
            if (isMouseDown && (!e.touches || e.touches.length === 1)) { 
                clearTimeout(longPressTimer);
                if (!isDragging && (Math.hypot(coords.x - dragStartPos.x, coords.y - dragStartPos.y) > 5)) { 
                    isDragging = true;
                }
                if (isDragging) {
                    cursorStyle = 'grabbing';
                    const dx = coords.x - lastDragPosition.x;
                    const dy = coords.y - lastDragPosition.y;
                    viewTransform.translateX += dx;
                    viewTransform.translateY += dy;
                    lastDragPosition = { x: coords.x, y: coords.y };
                    drawMap();
                }
            }
            dom.canvas.style.cursor = cursorStyle; 
        }
        
        function onInteractionEnd(e) {
            clearTimeout(longPressTimer);
            if (!isDragging) { 
                if (hoveredSystem) {
                    if (e.shiftKey) { 
                         if (hoveredSystem.catapult_radius > 0) {
                            const systemId = String(hoveredSystem.id);
                            if (toggledCatapultIds.has(systemId)) { toggledCatapultIds.delete(systemId); } 
                            else { toggledCatapultIds.add(systemId); }
                        }
                    } else if (activeRouteInput) { 
                        const sysPosStr = systems[hoveredSystem.id]?.position; 
                        if (hoveredSystem.name.startsWith("System ") && sysPosStr) {
                            activeRouteInput.value = `#${sysPosStr}`;
                        } else {
                            activeRouteInput.value = hoveredSystem.name;
                        }

                        if (activeRouteInput === dom.startSystemInput) { dom.endSystemInput.focus(); } 
                        else { dom.routeForm.querySelector('button[type="submit"]').focus(); }
                        activeRouteInput = null; 
                    }
                    highlightedCatapultSystemId = hoveredSystem.id; 
                } else {
                    highlightedCatapultSystemId = null; 
                }
                drawMap();
            }
            isMouseDown = false;
            isDragging = false;
            initialTouchDistance = null;
            dom.canvas.style.cursor = hoveredSystem ? 'pointer' : 'grab'; 
            localStorage.setItem('mapViewTransform', JSON.stringify(viewTransform)); 
        }

        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);
            dom.loginForm.addEventListener('submit', handleLogin);
            dom.registerForm.addEventListener('submit', handleRegister);
            dom.logoutButton.addEventListener('click', handleLogout);
            dom.syncButton.addEventListener('click', handleSync);
            dom.profileButton.addEventListener('click', openProfile);
            dom.closeProfileButton.addEventListener('click', closeProfile);
            dom.profileForm.addEventListener('submit', handleProfileUpdate);
            dom.showRegisterViewButton.addEventListener('click', showRegisterView);
            dom.showLoginViewButton.addEventListener('click', showLoginView);
            dom.toggleUnclaimedNames.addEventListener('change', (e) => { showUnclaimedNames = e.target.checked; drawMap(); });
            dom.resetViewButton.addEventListener('click', handleResetView);
            dom.menuButton.addEventListener('click', toggleSidePanel);
            dom.centerMeButton.addEventListener('click', centerOnMyLocation); 
            
            dom.addWaypointBtn.addEventListener('click', addWaypointInput);
            dom.routeForm.addEventListener('submit', (e) => {
                e.preventDefault();
                findPath(); 
            });

            dom.searchForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const query = dom.searchInput.value.trim().toLowerCase();
                const foundSystem = Object.values(systems).find(s => 
                    (s.name && s.name.toLowerCase() === query) || 
                    (s.position && `#${s.position}` === query)
                 );
                if (foundSystem && typeof foundSystem.x === 'number') { 
                    viewTransform.scale = 1.5; 
                    viewTransform.translateX = (dom.canvas.width / 2) - (foundSystem.x * viewTransform.scale);
                    viewTransform.translateY = (dom.canvas.height / 2) - (foundSystem.y * viewTransform.scale);
                    
                    highlightedSearchSystemId = foundSystem.id;
                    drawMap();
                    localStorage.setItem('mapViewTransform', JSON.stringify(viewTransform)); 

                    setTimeout(() => {
                        if (highlightedSearchSystemId === foundSystem.id) { 
                            highlightedSearchSystemId = null;
                            drawMap();
                        }
                    }, 2000);
                } else {
                    alert("System not found or has invalid coordinates in your discovered map.");
                }
            });

            dom.filterCatapults.addEventListener('change', (e) => { filterShowCatapults = e.target.checked; drawMap(); });
            dom.filterWormholes.addEventListener('change', (e) => { filterShowWormholes = e.target.checked; drawMap(); });
            dom.bulkSyncButton.addEventListener('click', handleBulkSync);

            dom.startSystemInput.addEventListener('focus', () => { activeRouteInput = dom.startSystemInput; });
            dom.endSystemInput.addEventListener('focus', () => { activeRouteInput = dom.endSystemInput; });
            document.addEventListener('click', (e) => { if (!dom.routeForm.contains(e.target) && !dom.canvas.contains(e.target)) { activeRouteInput = null; }});
            dom.routeDetailsContainer.addEventListener('click', (e) => { if (e.target && e.target.id === 'clear-route-button') { clearRouteDisplay(); } });

            dom.canvas.addEventListener('mousedown', onInteractionStart); 
            dom.canvas.addEventListener('mousemove', onInteractionMove);
            dom.canvas.addEventListener('mouseup', onInteractionEnd); 
            dom.canvas.addEventListener('mouseleave', onInteractionEnd); 
            dom.canvas.addEventListener('wheel', (e) => { 
                e.preventDefault(); 
                const scaleAmount = 1.1;
                const rect = dom.canvas.getBoundingClientRect();
                const mX=e.clientX - rect.left, mY=e.clientY - rect.top; 
                const wX=(mX-viewTransform.translateX)/viewTransform.scale, wY=(mY-viewTransform.translateY)/viewTransform.scale; 
                
                if(e.deltaY < 0) viewTransform.scale *= scaleAmount; 
                else viewTransform.scale /= scaleAmount; 
                
                viewTransform.scale = Math.max(0.05, Math.min(viewTransform.scale, 10)); 

                viewTransform.translateX=mX-wX*viewTransform.scale; 
                viewTransform.translateY=mY-wY*viewTransform.scale; 
                drawMap(); 
                localStorage.setItem('mapViewTransform', JSON.stringify(viewTransform)); 
            }, { passive: false }); 
            
            dom.canvas.addEventListener('touchstart', onInteractionStart, { passive: false }); 
            dom.canvas.addEventListener('touchmove', onInteractionMove, { passive: false }); 
            dom.canvas.addEventListener('touchend', onInteractionEnd);
            dom.canvas.addEventListener('touchcancel', onInteractionEnd); 
            
            // Context Menu Listener
            dom.canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const rect = dom.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldX = (x - viewTransform.translateX) / viewTransform.scale;
                const worldY = (y - viewTransform.translateY) / viewTransform.scale;
                
                // Check if clicked on existing marker
                let clickedMarker = null;
                for (const marker of intelMarkers) {
                    const dx = worldX - marker.x;
                    const dy = worldY - marker.y;
                    // Check hit radius (slightly larger than drawn size for easier clicking)
                    if (Math.sqrt(dx*dx + dy*dy) < (15 / viewTransform.scale)) {
                        clickedMarker = marker;
                        break;
                    }
                }
                openContextMenu(e.clientX, e.clientY, worldX, worldY, clickedMarker);
            });
        }
        
        setupEventListeners();
        checkLoginStatus();
    });
    </script>
</body>
</html>